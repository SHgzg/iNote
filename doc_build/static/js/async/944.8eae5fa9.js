"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["944"],{7499:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var s=r(5893),i=r(65);function d(e){let n=Object.assign({p:"p",strong:"strong",code:"code",hr:"hr",h2:"h2",a:"a",h3:"h3",h4:"h4",pre:"pre",ul:"ul",li:"li",ol:"ol"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["TypeScript 的类型系统非常强大，除了前面提到的内置工具类型和高级类型操作技巧外，还有一些",(0,s.jsx)(n.strong,{children:"更深入、更灵活"}),"的类型编程方法，包括",(0,s.jsx)(n.strong,{children:"分布式条件类型"}),"、",(0,s.jsxs)(n.strong,{children:["类型推断与 ",(0,s.jsx)(n.code,{children:"infer"})," 的高级用法"]}),"、",(0,s.jsx)(n.strong,{children:"递归类型的高级应用"}),"、",(0,s.jsx)(n.strong,{children:"类型守卫与类型断言的结合"}),"，以及一些",(0,s.jsx)(n.strong,{children:"实用但较少被提及的技巧"}),"。"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"六更深入的类型编程技巧",children:[(0,s.jsx)(n.strong,{children:"六、更深入的类型编程技巧"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#六更深入的类型编程技巧",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1-分布式条件类型distributive-conditional-types",children:[(0,s.jsx)(n.strong,{children:"1. 分布式条件类型（Distributive Conditional Types）"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-分布式条件类型distributive-conditional-types",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["当条件类型作用于",(0,s.jsx)(n.strong,{children:"联合类型"}),'时，TypeScript 会自动将条件类型"分配"到联合类型的每个成员上，这就是',(0,s.jsx)(n.strong,{children:"分布式条件类型"}),"。"]}),"\n",(0,s.jsxs)(n.h4,{id:"基本示例",children:[(0,s.jsx)(n.strong,{children:"基本示例"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本示例",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ToArray<T> = T extends any ? T[] : never;\r\n\r\ntype StrOrNumArray = ToArray<string | number>;\r\n// 等同于 string[] | number[]\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ToArray<string | number>"})," 会被拆解为 ",(0,s.jsx)(n.code,{children:"string[] | number[]"}),"，因为 ",(0,s.jsx)(n.code,{children:"T"})," 是联合类型 ",(0,s.jsx)(n.code,{children:"string | number"}),"，条件类型会分别应用于 ",(0,s.jsx)(n.code,{children:"string"})," 和 ",(0,s.jsx)(n.code,{children:"number"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"关闭分布式行为",children:[(0,s.jsx)(n.strong,{children:"关闭分布式行为"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关闭分布式行为",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果不想让条件类型自动分配，可以用",(0,s.jsx)(n.code,{children:"[]"}),"包裹",(0,s.jsx)(n.code,{children:"T"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ToArrayNonDistributive<T> = [T] extends [any] ? T[] : never;\r\n\r\ntype StrOrNumArrayNonDistributive = ToArrayNonDistributive<string | number>;\r\n// 等同于 (string | number)[]\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[T] extends [any]"})," 使得 ",(0,s.jsx)(n.code,{children:"T"})," 不再被视为联合类型，而是作为一个整体处理。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"实际应用",children:[(0,s.jsx)(n.strong,{children:"实际应用"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实际应用",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Filter<T, U> = T extends U ? T : never;\r\n\r\ntype NumbersOnly = Filter<string | number | boolean, number>;\r\n// 等同于 number\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Filter"})," 会从联合类型中筛选出符合 ",(0,s.jsx)(n.code,{children:"U"})," 的类型。"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"2--的高级用法",children:[(0,s.jsxs)(n.strong,{children:["2. ",(0,s.jsx)(n.code,{children:"infer"})," 的高级用法"]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2--的高级用法",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"infer"})," 不仅可以用于函数返回类型推断，还可以用于",(0,s.jsx)(n.strong,{children:"更复杂的类型结构"}),"，如："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"推断函数参数类型"}),"\n",(0,s.jsx)(n.li,{children:"推断数组元素类型"}),"\n",(0,s.jsx)(n.li,{children:"推断对象属性类型"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"1-推断函数参数类型",children:[(0,s.jsx)(n.strong,{children:"(1) 推断函数参数类型"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-推断函数参数类型",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type FirstArg<T> = T extends (arg: infer P, ...rest: any[]) => any ? P : never;\r\n\r\ntype Fn = (name: string, age: number) => void;\r\ntype FirstArgType = FirstArg<Fn>; // string\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"2-推断数组元素类型",children:[(0,s.jsx)(n.strong,{children:"(2) 推断数组元素类型"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-推断数组元素类型",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ElementType<T> = T extends (infer U)[] ? U : never;\r\n\r\ntype Arr = string[];\r\ntype ElementTypeArr = ElementType<Arr>; // string\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"3-推断-promise-的解析类型",children:[(0,s.jsx)(n.strong,{children:"(3) 推断 Promise 的解析类型"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-推断-promise-的解析类型",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\r\n\r\ntype PromiseString = Promise<string>;\r\ntype Unwrapped = UnwrapPromise<PromiseString>; // string\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"4-推断对象属性类型",children:[(0,s.jsx)(n.strong,{children:"(4) 推断对象属性类型"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-推断对象属性类型",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ValueType<T> = T extends { value: infer V } ? V : never;\r\n\r\ntype Obj = { value: number };\r\ntype ValueTypeObj = ValueType<Obj>; // number\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"3-递归类型的高级应用",children:[(0,s.jsx)(n.strong,{children:"3. 递归类型的高级应用"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-递归类型的高级应用",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["递归类型不仅可以用于",(0,s.jsxs)(n.strong,{children:["深度 ",(0,s.jsx)(n.code,{children:"Partial"})," 或 ",(0,s.jsx)(n.code,{children:"DeepReadonly"})]}),"，还可以用于："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"递归遍历对象属性"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"递归转换类型"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"递归生成复杂类型"})}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"1-递归-前面已讲",children:[(0,s.jsxs)(n.strong,{children:["(1) 递归 ",(0,s.jsx)(n.code,{children:"DeepPartial"}),"（前面已讲）"]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-递归-前面已讲",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepPartial<T> = {\r\n  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];\r\n};\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"2-递归",children:[(0,s.jsxs)(n.strong,{children:["(2) 递归 ",(0,s.jsx)(n.code,{children:"DeepReadonly"})]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-递归",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepReadonly<T> = {\r\n  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];\r\n};\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"3-递归",children:[(0,s.jsxs)(n.strong,{children:["(3) 递归 ",(0,s.jsx)(n.code,{children:"DeepRequired"})]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-递归",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepRequired<T> = {\r\n  [K in keyof T]-?: T[K] extends object ? DeepRequired<T[K]> : T[K];\r\n};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"-?"})," 表示移除可选修饰符，使属性变为必选。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"4-递归",children:[(0,s.jsxs)(n.strong,{children:["(4) 递归 ",(0,s.jsx)(n.code,{children:"DeepNullable"})]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-递归",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepNullable<T> = {\r\n  [K in keyof T]: T[K] extends object ? DeepNullable<T[K]> : T[K] | null;\r\n};\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"5-递归-扁平化嵌套数组",children:[(0,s.jsxs)(n.strong,{children:["(5) 递归 ",(0,s.jsx)(n.code,{children:"Flatten"}),"（扁平化嵌套数组）"]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-递归-扁平化嵌套数组",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Flatten<T> = T extends (infer U)[] ? Flatten<U> : T;\r\n\r\ntype NestedArray = string[][][];\r\ntype Flattened = Flatten<NestedArray>; // string\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"6-递归-元组转联合类型",children:[(0,s.jsxs)(n.strong,{children:["(6) 递归 ",(0,s.jsx)(n.code,{children:"TupleToUnion"}),"（元组转联合类型）"]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-递归-元组转联合类型",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type TupleToUnion<T extends any[]> = T[number];\r\n\r\ntype Tuple = [string, number, boolean];\r\ntype Union = TupleToUnion<Tuple>; // string | number | boolean\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"4-类型守卫与类型断言的结合",children:[(0,s.jsx)(n.strong,{children:"4. 类型守卫与类型断言的结合"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-类型守卫与类型断言的结合",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["TypeScript 的类型守卫（",(0,s.jsx)(n.code,{children:"typeof"}),"、",(0,s.jsx)(n.code,{children:"instanceof"}),"、",(0,s.jsx)(n.code,{children:"in"}),"）可以与类型断言结合，实现更灵活的类型控制。"]}),"\n",(0,s.jsxs)(n.h4,{id:"1-自定义类型守卫",children:[(0,s.jsx)(n.strong,{children:"(1) 自定义类型守卫"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-自定义类型守卫",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function isString(value: unknown): value is string {\r\n  return typeof value === 'string';\r\n}\r\n\r\nfunction process(value: string | number) {\r\n  if (isString(value)) {\r\n    // 这里 value 被推断为 string\r\n    console.log(value.toUpperCase());\r\n  } else {\r\n    // 这里 value 被推断为 number\r\n    console.log(value.toFixed(2));\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"2-类型断言--类型守卫",children:[(0,s.jsx)(n.strong,{children:"(2) 类型断言 + 类型守卫"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-类型断言--类型守卫",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Cat = { meow: () => void };\r\ntype Dog = { bark: () => void };\r\n\r\nfunction isCat(animal: Cat | Dog): animal is Cat {\r\n  return 'meow' in animal;\r\n}\r\n\r\nfunction makeSound(animal: Cat | Dog) {\r\n  if (isCat(animal)) {\r\n    animal.meow(); // 类型安全\r\n  } else {\r\n    animal.bark(); // 类型安全\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"5-实用但较少被提及的技巧",children:[(0,s.jsx)(n.strong,{children:"5. 实用但较少被提及的技巧"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-实用但较少被提及的技巧",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"1--类型查询",children:[(0,s.jsxs)(n.strong,{children:["(1) ",(0,s.jsx)(n.code,{children:"typeof"})," 类型查询"]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1--类型查询",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const person = { name: 'Alice', age: 30 };\r\ntype PersonType = typeof person; // { name: string; age: number; }\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"2----组合",children:[(0,s.jsxs)(n.strong,{children:["(2) ",(0,s.jsx)(n.code,{children:"keyof"})," + ",(0,s.jsx)(n.code,{children:"typeof"})," 组合"]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2----组合",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const colors = { red: '#FF0000', green: '#00FF00', blue: '#0000FF' };\r\ntype ColorKeys = keyof typeof colors; // 'red' | 'green' | 'blue'\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"3--运算符typescript-49",children:[(0,s.jsxs)(n.strong,{children:["(3) ",(0,s.jsx)(n.code,{children:"satisfies"})," 运算符（TypeScript 4.9+）"]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3--运算符typescript-49",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Theme = {\r\n  color: string;\r\n  fontSize: number;\r\n};\r\n\r\nconst theme = {\r\n  color: '#FF0000',\r\n  fontSize: 14,\r\n  // extraProp: true, // ❌ 报错，因为不符合 Theme 类型\r\n} satisfies Theme;\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"satisfies"})," 确保对象符合类型，但不会改变对象的类型推断。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"4--断言",children:[(0,s.jsxs)(n.strong,{children:["(4) ",(0,s.jsx)(n.code,{children:"const"})," 断言"]}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4--断言",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const colors = ['red', 'green', 'blue'] as const;\r\n// 类型推断为 readonly ['red', 'green', 'blue']\r\ntype Colors = typeof colors[number]; // 'red' | 'green' | 'blue'\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"七总结",children:[(0,s.jsx)(n.strong,{children:"七、总结"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#七总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 的类型系统非常灵活，除了内置工具类型和基础高级技巧外，还可以通过："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"分布式条件类型"})," 处理联合类型"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"infer"})," 高级推断"]})," 提取复杂类型"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"递归类型"})," 处理嵌套结构"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"类型守卫 + 类型断言"})," 实现运行时类型安全"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"typeof"})," + ",(0,s.jsx)(n.code,{children:"keyof"})," 组合"]})," 动态获取类型"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"satisfies"})," 和 ",(0,s.jsx)(n.code,{children:"const"})," 断言"]})," 增强类型安全性"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这些技巧可以组合使用，构建出",(0,s.jsx)(n.strong,{children:"极其强大且类型安全"}),"的 TypeScript 代码。掌握它们，可以让你写出更健壮、更易维护的 TypeScript 项目！ \uD83D\uDE80"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["typescript%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%B1%BB%E5%9E%8B%E6%8A%80%E5%B7%A7%2F2.%E4%B8%8D%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7.md"]={toc:[{text:"**六、更深入的类型编程技巧**",id:"六更深入的类型编程技巧",depth:2},{text:"**1. 分布式条件类型（Distributive Conditional Types）**",id:"1-分布式条件类型distributive-conditional-types",depth:3},{text:"**基本示例**",id:"基本示例",depth:4},{text:"**关闭分布式行为**",id:"关闭分布式行为",depth:4},{text:"**实际应用**",id:"实际应用",depth:4},{text:"**2. **",id:"2-",depth:3},{text:"**(1) 推断函数参数类型**",id:"1-推断函数参数类型",depth:4},{text:"**(2) 推断数组元素类型**",id:"2-推断数组元素类型",depth:4},{text:"**(3) 推断 Promise 的解析类型**",id:"3-推断-promise-的解析类型",depth:4},{text:"**(4) 推断对象属性类型**",id:"4-推断对象属性类型",depth:4},{text:"**3. 递归类型的高级应用**",id:"3-递归类型的高级应用",depth:3},{text:"**(1) 递归 **",id:"1-递归-",depth:4},{text:"**(2) 递归 **",id:"2-递归-",depth:4},{text:"**(3) 递归 **",id:"3-递归-",depth:4},{text:"**(4) 递归 **",id:"4-递归-",depth:4},{text:"**(5) 递归 **",id:"5-递归-",depth:4},{text:"**(6) 递归 **",id:"6-递归-",depth:4},{text:"**4. 类型守卫与类型断言的结合**",id:"4-类型守卫与类型断言的结合",depth:3},{text:"**(1) 自定义类型守卫**",id:"1-自定义类型守卫",depth:4},{text:"**(2) 类型断言 + 类型守卫**",id:"2-类型断言--类型守卫",depth:4},{text:"**5. 实用但较少被提及的技巧**",id:"5-实用但较少被提及的技巧",depth:3},{text:"**(1) **",id:"1-",depth:4},{text:"**(2) **",id:"2--1",depth:4},{text:"**(3) **",id:"3-",depth:4},{text:"**(4) **",id:"4-",depth:4},{text:"**七、总结**",id:"七总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);