"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["936"],{2620:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var s=r(5893),i=r(65);function a(e){let n=Object.assign({p:"p",hr:"hr",h2:"h2",a:"a",h3:"h3",code:"code",pre:"pre",h4:"h4",ol:"ol",li:"li",strong:"strong",ul:"ul"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"在 TypeScript 中，从已有类型中提取部分类型，并组合成新的类型，是类型编程（Type Programming）的核心能力之一。TypeScript 提供了多种方式来实现这一目标，包括内置的工具类型（Utility Types）以及更高级的类型操作技巧。以下是 TypeScript 中从类型中获取类型并合成新类型的所有主要方法，按类别进行整理和说明。"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"一使用内置的工具类型utility-types",children:["一、使用内置的工具类型（Utility Types）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一使用内置的工具类型utility-types",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 提供了一系列内置的工具类型，用于从已有类型中提取或转换部分类型，从而合成新的类型。"}),"\n",(0,s.jsxs)(n.h3,{id:"1-partialt",children:["1. ",(0,s.jsx)(n.code,{children:"Partial<T>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-partialt",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["将类型 ",(0,s.jsx)(n.code,{children:"T"})," 的所有属性变为可选。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\n\r\ntype PartialPerson = Partial<Person>;\r\n// 等同于 { name?: string; age?: number; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-requiredt",children:["2. ",(0,s.jsx)(n.code,{children:"Required<T>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-requiredt",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["将类型 ",(0,s.jsx)(n.code,{children:"T"})," 的所有属性变为必选。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type RequiredPerson = Required<PartialPerson>;\r\n// 等同于 { name: string; age: number; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"3-readonlyt",children:["3. ",(0,s.jsx)(n.code,{children:"Readonly<T>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-readonlyt",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["将类型 ",(0,s.jsx)(n.code,{children:"T"})," 的所有属性变为只读。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ReadonlyPerson = Readonly<Person>;\r\n// 等同于 { readonly name: string; readonly age: number; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"4-recordk-t",children:["4. ",(0,s.jsx)(n.code,{children:"Record<K, T>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-recordk-t",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["构造一个键类型为 ",(0,s.jsx)(n.code,{children:"K"}),"，值类型为 ",(0,s.jsx)(n.code,{children:"T"})," 的对象类型。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type UserRoles = Record<string, string>;\r\n// 等同于 { [key: string]: string; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"5-pickt-k",children:["5. ",(0,s.jsx)(n.code,{children:"Pick<T, K>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-pickt-k",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["从类型 ",(0,s.jsx)(n.code,{children:"T"})," 中选取指定的属性 ",(0,s.jsx)(n.code,{children:"K"})," 来构造新类型。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type NameOnly = Pick<Person, 'name'>;\r\n// 等同于 { name: string; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"6-omitt-k",children:["6. ",(0,s.jsx)(n.code,{children:"Omit<T, K>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-omitt-k",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["从类型 ",(0,s.jsx)(n.code,{children:"T"})," 中排除指定的属性 ",(0,s.jsx)(n.code,{children:"K"})," 来构造新类型。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type AgeOnly = Omit<Person, 'name'>;\r\n// 等同于 { age: number; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"7-excludet-u",children:["7. ",(0,s.jsx)(n.code,{children:"Exclude<T, U>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-excludet-u",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["从联合类型 ",(0,s.jsx)(n.code,{children:"T"})," 中排除可以赋值给 ",(0,s.jsx)(n.code,{children:"U"})," 的类型。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type T = 'a' | 'b' | 'c';\r\ntype U = 'a' | 'b';\r\ntype Result = Exclude<T, U>;\r\n// 等同于 'c'\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"8-extractt-u",children:["8. ",(0,s.jsx)(n.code,{children:"Extract<T, U>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-extractt-u",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["从联合类型 ",(0,s.jsx)(n.code,{children:"T"})," 中提取可以赋值给 ",(0,s.jsx)(n.code,{children:"U"})," 的类型。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Result = Extract<T, U>;\r\n// 等同于 'a' | 'b'\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"9-nonnullablet",children:["9. ",(0,s.jsx)(n.code,{children:"NonNullable<T>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-nonnullablet",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["从类型 ",(0,s.jsx)(n.code,{children:"T"})," 中排除 ",(0,s.jsx)(n.code,{children:"null"})," 和 ",(0,s.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type T = string | null | undefined;\r\ntype NonNullableT = NonNullable<T>;\r\n// 等同于 string\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"10-returntypet",children:["10. ",(0,s.jsx)(n.code,{children:"ReturnType<T>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-returntypet",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["获取函数类型 ",(0,s.jsx)(n.code,{children:"T"})," 的返回类型。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function getUser(): Person {\r\n  return { name: 'Alice', age: 30 };\r\n}\r\n\r\ntype UserReturnType = ReturnType<typeof getUser>;\r\n// 等同于 Person\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"11-parameterst",children:["11. ",(0,s.jsx)(n.code,{children:"Parameters<T>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-parameterst",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["获取函数类型 ",(0,s.jsx)(n.code,{children:"T"})," 的参数类型组成的元组类型。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function greet(name: string, age: number): void {}\r\n\r\ntype GreetParams = Parameters<typeof greet>;\r\n// 等同于 [string, number]\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"12-constructorparameterst",children:["12. ",(0,s.jsx)(n.code,{children:"ConstructorParameters<T>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-constructorparameterst",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["获取构造函数类型 ",(0,s.jsx)(n.code,{children:"T"})," 的参数类型组成的元组类型。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class PersonClass {\r\n  constructor(public name: string, public age: number) {}\r\n}\r\n\r\ntype PersonParams = ConstructorParameters<typeof PersonClass>;\r\n// 等同于 [string, number]\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"13-uppercaset-lowercaset-capitalizet-uncapitalizet",children:["13. ",(0,s.jsx)(n.code,{children:"Uppercase<T>"}),", ",(0,s.jsx)(n.code,{children:"Lowercase<T>"}),", ",(0,s.jsx)(n.code,{children:"Capitalize<T>"}),", ",(0,s.jsx)(n.code,{children:"Uncapitalize<T>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-uppercaset-lowercaset-capitalizet-uncapitalizet",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"字符串字面量类型的转换工具类型（TypeScript 4.1+）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type T = 'hello';\r\ntype UppercaseT = Uppercase<T>; // 'HELLO'\r\ntype LowercaseT = Lowercase<T>; // 'hello'\r\ntype CapitalizeT = Capitalize<T>; // 'Hello'\r\ntype UncapitalizeT = Uncapitalize<T>; // 'hello'\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"二高级类型操作技巧",children:["二、高级类型操作技巧",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二高级类型操作技巧",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"除了内置的工具类型，TypeScript 还支持更高级的类型操作，通过条件类型、映射类型、索引访问等实现更灵活的类型合成。"}),"\n",(0,s.jsxs)(n.h3,{id:"1-条件类型conditional-types",children:["1. 条件类型（Conditional Types）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-条件类型conditional-types",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"extends"})," 关键字进行类型条件判断，实现类型的分支选择。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type IsString<T> = T extends string ? true : false;\r\n\r\ntype A = IsString<'hello'>; // true\r\ntype B = IsString<123>; // false\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"常见应用infer-关键字",children:["常见应用：",(0,s.jsx)(n.code,{children:"infer"})," 关键字",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见应用infer-关键字",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"infer"})," 用于在条件类型中推断出某个类型，并在后续使用。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ReturnTypeCustom<T> = T extends (...args: any[]) => infer R ? R : never;\r\n\r\ntype UserReturnTypeCustom = ReturnTypeCustom<typeof getUser>;\r\n// 等同于 Person\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-映射类型mapped-types",children:["2. 映射类型（Mapped Types）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-映射类型mapped-types",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过遍历已有类型的属性，进行转换或筛选，构造新的类型。"}),"\n",(0,s.jsxs)(n.h4,{id:"基本映射类型",children:["基本映射类型",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本映射类型",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Optional<T> = {\r\n  [P in keyof T]?: T[P];\r\n};\r\n\r\ntype OptionalPerson = Optional<Person>;\r\n// 等同于 { name?: string; age?: number; }\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"结合条件类型进行筛选",children:["结合条件类型进行筛选",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#结合条件类型进行筛选",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type StringKeys<T> = {\r\n  [K in keyof T as T[K] extends string ? K : never]: T[K];\r\n};\r\n\r\ninterface Mixed {\r\n  name: string;\r\n  age: number;\r\n  email: string;\r\n}\r\n\r\ntype StringOnly = StringKeys<Mixed>;\r\n// 等同于 { name: string; email: string; }\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"使用-keyof-和索引访问",children:["使用 ",(0,s.jsx)(n.code,{children:"keyof"})," 和索引访问",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-keyof-和索引访问",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ValueOf<T> = T[keyof T];\r\n\r\ntype PersonValues = ValueOf<Person>;\r\n// 等同于 string | number\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"3-模板字面量类型template-literal-types",children:["3. 模板字面量类型（Template Literal Types）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-模板字面量类型template-literal-types",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 4.1 引入了模板字面量类型，允许通过字符串字面量的组合来构造新的类型。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type EventName = 'click' | 'scroll' | 'hover';\r\ntype HandlerName = `on${Capitalize<EventName>}`;\r\n\r\n// 等同于 'onClick' | 'onScroll' | 'onHover'\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"4-递归类型",children:["4. 递归类型",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-递归类型",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 支持递归类型定义，允许类型在自身内部引用自己，用于处理嵌套结构。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepPartial<T> = {\r\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\r\n};\r\n\r\ninterface NestedPerson {\r\n  name: string;\r\n  address: {\r\n    city: string;\r\n    zip: number;\r\n  };\r\n}\r\n\r\ntype PartialNestedPerson = DeepPartial<NestedPerson>;\r\n// 等同于 { name?: string; address?: { city?: string; zip?: number; }; }\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"三组合使用工具类型与高级技巧",children:["三、组合使用工具类型与高级技巧",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三组合使用工具类型与高级技巧",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在实际开发中，往往需要组合使用内置的工具类型与高级的类型操作技巧，以实现更复杂的类型合成需求。"}),"\n",(0,s.jsxs)(n.h3,{id:"示例-1从对象类型中提取特定类型的属性",children:["示例 1：从对象类型中提取特定类型的属性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#示例-1从对象类型中提取特定类型的属性",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["假设有一个对象类型，想要提取所有属性值为 ",(0,s.jsx)(n.code,{children:"string"})," 类型的属性。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type StringProps<T> = {\r\n  [K in keyof T as T[K] extends string ? K : never]: T[K];\r\n};\r\n\r\ninterface Example {\r\n  name: string;\r\n  age: number;\r\n  email: string;\r\n}\r\n\r\ntype StringOnlyExample = StringProps<Example>;\r\n// 等同于 { name: string; email: string; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"示例-2合并多个类型",children:["示例 2：合并多个类型",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#示例-2合并多个类型",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"假设有多个类型，想要将它们的属性合并成一个新的类型，同时处理属性冲突（如使用联合类型）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Merge<T, U> = {\r\n  [K in keyof T | keyof U]: \r\n    K extends keyof U ? U[K] :\r\n    K extends keyof T ? T[K] :\r\n    never;\r\n};\r\n\r\ninterface A {\r\n  a: string;\r\n  b: number;\r\n}\r\n\r\ninterface B {\r\n  b: boolean;\r\n  c: string;\r\n}\r\n\r\ntype Merged = Merge<A, B>;\r\n// 等同于 { a: string; b: boolean; c: string; }\r\n// 注意：属性 'b' 的类型被 B 中的类型覆盖\n"})}),"\n",(0,s.jsx)(n.p,{children:"如果需要更复杂的合并策略（如联合类型），可以进一步定制："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type UnionMerge<T, U> = {\r\n  [K in keyof T | keyof U]: \r\n    K extends keyof T & keyof U ? T[K] | U[K] :\r\n    K extends keyof T ? T[K] :\r\n    K extends keyof U ? U[K] :\r\n    never;\r\n};\r\n\r\ntype UnionMerged = UnionMerge<A, B>;\r\n// 等同于 { a: string; b: number | boolean; c: string; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"示例-3提取函数返回类型并组合",children:["示例 3：提取函数返回类型并组合",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#示例-3提取函数返回类型并组合",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"假设有多个函数类型，想要提取它们的返回类型，并组合成一个新的联合类型。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type FunctionReturnUnion<T extends (...args: any[]) => any[]> = \r\n  ReturnType<T[0]> | ... | ReturnType<T[n]>;\r\n\r\n// 实际中，TypeScript 不支持直接对元组类型的每个元素应用 ReturnType，\r\n// 可以使用递归或展开的方式。\r\n\r\n// 简单示例：两个函数\r\ntype Func1 = () => string;\r\ntype Func2 = () => number;\r\n\r\ntype ReturnUnion = ReturnType<Func1> | ReturnType<Func2>;\r\n// 等同于 string | number\n"})}),"\n",(0,s.jsx)(n.p,{children:"对于多个函数，可以定义一个工具类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ReturnUnion<T extends Array<(...args: any[]) => any>> = \r\n  T extends [infer F, ...infer R] \r\n    ? ReturnType<F> | ReturnUnion<R> \r\n    : never;\r\n\r\ntype Funcs = [() => string, () => number, () => boolean];\r\ntype UnionReturn = ReturnUnion<Funcs>;\r\n// 等同于 string | number | boolean\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"四实用技巧与最佳实践",children:["四、实用技巧与最佳实践",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四实用技巧与最佳实践",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1-使用-as-进行键的重映射",children:["1. 使用 ",(0,s.jsx)(n.code,{children:"as"})," 进行键的重映射",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-使用-as-进行键的重映射",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在映射类型中，可以使用 ",(0,s.jsx)(n.code,{children:"as"})," 子句对键进行重映射，实现更灵活的类型转换。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Getters<T> = {\r\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\r\n};\r\n\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\n\r\ntype PersonGetters = Getters<Person>;\r\n// 等同于 { getName: () => string; getAge: () => number; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-过滤掉某些属性",children:["2. 过滤掉某些属性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-过滤掉某些属性",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"结合条件类型与映射类型，可以过滤掉不需要的属性。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type FilterProperties<T, U> = {\r\n  [K in keyof T as T[K] extends U ? K : never]: T[K];\r\n};\r\n\r\ninterface MixedData {\r\n  name: string;\r\n  age: number;\r\n  email: string;\r\n  isActive: boolean;\r\n}\r\n\r\ntype StringPropsOnly = FilterProperties<MixedData, string>;\r\n// 等同于 { name: string; email: string; }\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"3-动态生成类型",children:["3. 动态生成类型",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-动态生成类型",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"利用泛型和条件类型，可以根据输入动态生成新的类型。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Nullable<T> = {\r\n  [K in keyof T]: T[K] | null;\r\n};\r\n\r\ninterface Data {\r\n  id: number;\r\n  name: string;\r\n}\r\n\r\ntype NullableData = Nullable<Data>;\r\n// 等同于 { id: number | null; name: string | null; }\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"五总结",children:["五、总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 提供了丰富的内置工具类型和强大的类型操作能力，允许开发者从已有类型中提取、转换和组合出新的类型。以下是主要的方法汇总："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"内置工具类型"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Partial"}),", ",(0,s.jsx)(n.code,{children:"Required"}),", ",(0,s.jsx)(n.code,{children:"Readonly"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Record"}),", ",(0,s.jsx)(n.code,{children:"Pick"}),", ",(0,s.jsx)(n.code,{children:"Omit"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Exclude"}),", ",(0,s.jsx)(n.code,{children:"Extract"}),", ",(0,s.jsx)(n.code,{children:"NonNullable"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ReturnType"}),", ",(0,s.jsx)(n.code,{children:"Parameters"}),", ",(0,s.jsx)(n.code,{children:"ConstructorParameters"})]}),"\n",(0,s.jsxs)(n.li,{children:["字符串转换工具类型：",(0,s.jsx)(n.code,{children:"Uppercase"}),", ",(0,s.jsx)(n.code,{children:"Lowercase"}),", ",(0,s.jsx)(n.code,{children:"Capitalize"}),", ",(0,s.jsx)(n.code,{children:"Uncapitalize"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"高级类型操作"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["条件类型与 ",(0,s.jsx)(n.code,{children:"infer"})," 关键字"]}),"\n",(0,s.jsxs)(n.li,{children:["映射类型与键的重映射 (",(0,s.jsx)(n.code,{children:"as"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["索引访问类型 (",(0,s.jsx)(n.code,{children:"T[K]"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"模板字面量类型"}),"\n",(0,s.jsx)(n.li,{children:"递归类型定义"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"组合与实用技巧"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"组合多个工具类型实现复杂类型转换"}),"\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"as"})," 进行键的重命名"]}),"\n",(0,s.jsx)(n.li,{children:"动态生成类型基于输入"}),"\n",(0,s.jsx)(n.li,{children:"过滤和筛选特定类型的属性"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"掌握这些方法，可以极大地提升 TypeScript 的类型安全性与代码的可维护性，使得类型系统成为开发中的强大助手，而不仅仅是约束工具。"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let d=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["typescript%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%B1%BB%E5%9E%8B%E6%8A%80%E5%B7%A7%2F1.%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8F%96%E4%B8%8E%E7%BB%84%E5%90%88.md"]={toc:[{text:"一、使用内置的工具类型（Utility Types）",id:"一使用内置的工具类型utility-types",depth:2},{text:"1. `Partial<T>`",id:"1-partialt",depth:3},{text:"2. `Required<T>`",id:"2-requiredt",depth:3},{text:"3. `Readonly<T>`",id:"3-readonlyt",depth:3},{text:"4. `Record<K, T>`",id:"4-recordk-t",depth:3},{text:"5. `Pick<T, K>`",id:"5-pickt-k",depth:3},{text:"6. `Omit<T, K>`",id:"6-omitt-k",depth:3},{text:"7. `Exclude<T, U>`",id:"7-excludet-u",depth:3},{text:"8. `Extract<T, U>`",id:"8-extractt-u",depth:3},{text:"9. `NonNullable<T>`",id:"9-nonnullablet",depth:3},{text:"10. `ReturnType<T>`",id:"10-returntypet",depth:3},{text:"11. `Parameters<T>`",id:"11-parameterst",depth:3},{text:"12. `ConstructorParameters<T>`",id:"12-constructorparameterst",depth:3},{text:"13. `Uppercase<T>`, `Lowercase<T>`, `Capitalize<T>`, `Uncapitalize<T>`",id:"13-uppercaset-lowercaset-capitalizet-uncapitalizet",depth:3},{text:"二、高级类型操作技巧",id:"二高级类型操作技巧",depth:2},{text:"1. 条件类型（Conditional Types）",id:"1-条件类型conditional-types",depth:3},{text:"常见应用：`infer` 关键字",id:"常见应用infer-关键字",depth:4},{text:"2. 映射类型（Mapped Types）",id:"2-映射类型mapped-types",depth:3},{text:"基本映射类型",id:"基本映射类型",depth:4},{text:"结合条件类型进行筛选",id:"结合条件类型进行筛选",depth:4},{text:"使用 `keyof` 和索引访问",id:"使用-keyof-和索引访问",depth:4},{text:"3. 模板字面量类型（Template Literal Types）",id:"3-模板字面量类型template-literal-types",depth:3},{text:"4. 递归类型",id:"4-递归类型",depth:3},{text:"三、组合使用工具类型与高级技巧",id:"三组合使用工具类型与高级技巧",depth:2},{text:"示例 1：从对象类型中提取特定类型的属性",id:"示例-1从对象类型中提取特定类型的属性",depth:3},{text:"示例 2：合并多个类型",id:"示例-2合并多个类型",depth:3},{text:"示例 3：提取函数返回类型并组合",id:"示例-3提取函数返回类型并组合",depth:3},{text:"四、实用技巧与最佳实践",id:"四实用技巧与最佳实践",depth:2},{text:"1. 使用 `as` 进行键的重映射",id:"1-使用-as-进行键的重映射",depth:3},{text:"2. 过滤掉某些属性",id:"2-过滤掉某些属性",depth:3},{text:"3. 动态生成类型",id:"3-动态生成类型",depth:3},{text:"五、总结",id:"五总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);