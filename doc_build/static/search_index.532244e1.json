[{"id":0,"title":"","content":"","routePath":"/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"home","hero":{"name":"Why Not ?","text":"A VitePress Site","tagline":"My great project tagline"},"features":[{"title":"JavaScript","details":"My JavaScript study notes","link":"/javascript\\index.md"},{"title":"TypeScript","details":"My JavaScript study notes","link":"/typescript\\index.md"}]},"version":""},{"id":1,"title":"","content":"","routePath":"/javascript/1.base","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"","content":"","routePath":"/javascript/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"home","hero":{"name":"JavaScript"},"name":"JavaScript","tagline":"My JavaScript study notes"},"version":""},{"id":3,"title":"","content":"one#","routePath":"/javascript/one","lang":"","toc":[{"text":"one","id":"one","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"","content":"sadfasdf#\n\nasdfasdf\n\nasdfasdf\n\n","routePath":"/javascript/test","lang":"","toc":[{"text":"sadfasdf","id":"sadfasdf","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"","content":"three#","routePath":"/javascript/three","lang":"","toc":[{"text":"three","id":"three","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"","content":"two#","routePath":"/javascript/two","lang":"","toc":[{"text":"two","id":"two","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"","content":"test#","routePath":"/typescript/1.base","lang":"","toc":[{"text":"test","id":"test","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"","content":"","routePath":"/typescript/2.class","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"","content":"","routePath":"/typescript/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"home","name":"TypeScript","tagline":"My JavaScript study notes"},"version":""},{"id":10,"title":"","content":"在 TypeScript 中，从已有类型中提取部分类型，并组合成新的类型，是类型编程（Type Programming）的核心能力之一。TypeScript\n提供了多种方式来实现这一目标，包括内置的工具类型（Utility Types）以及更高级的类型操作技巧。以下是 TypeScript\n中从类型中获取类型并合成新类型的所有主要方法，按类别进行整理和说明。\n\n--------------------------------------------------------------------------------\n\n\n一、使用内置的工具类型（Utility Types）#\n\nTypeScript 提供了一系列内置的工具类型，用于从已有类型中提取或转换部分类型，从而合成新的类型。\n\n\n1. Partial<T>#\n\n将类型 T 的所有属性变为可选。\n\n\n\n\n2. Required<T>#\n\n将类型 T 的所有属性变为必选。\n\n\n\n\n3. Readonly<T>#\n\n将类型 T 的所有属性变为只读。\n\n\n\n\n4. Record<K, T>#\n\n构造一个键类型为 K，值类型为 T 的对象类型。\n\n\n\n\n5. Pick<T, K>#\n\n从类型 T 中选取指定的属性 K 来构造新类型。\n\n\n\n\n6. Omit<T, K>#\n\n从类型 T 中排除指定的属性 K 来构造新类型。\n\n\n\n\n7. Exclude<T, U>#\n\n从联合类型 T 中排除可以赋值给 U 的类型。\n\n\n\n\n8. Extract<T, U>#\n\n从联合类型 T 中提取可以赋值给 U 的类型。\n\n\n\n\n9. NonNullable<T>#\n\n从类型 T 中排除 null 和 undefined。\n\n\n\n\n10. ReturnType<T>#\n\n获取函数类型 T 的返回类型。\n\n\n\n\n11. Parameters<T>#\n\n获取函数类型 T 的参数类型组成的元组类型。\n\n\n\n\n12. ConstructorParameters<T>#\n\n获取构造函数类型 T 的参数类型组成的元组类型。\n\n\n\n\n13. Uppercase<T>, Lowercase<T>, Capitalize<T>, Uncapitalize<T>#\n\n字符串字面量类型的转换工具类型（TypeScript 4.1+）。\n\n\n\n--------------------------------------------------------------------------------\n\n\n二、高级类型操作技巧#\n\n除了内置的工具类型，TypeScript 还支持更高级的类型操作，通过条件类型、映射类型、索引访问等实现更灵活的类型合成。\n\n\n1. 条件类型（Conditional Types）#\n\n使用 extends 关键字进行类型条件判断，实现类型的分支选择。\n\n\n\n常见应用：infer 关键字#\n\ninfer 用于在条件类型中推断出某个类型，并在后续使用。\n\n\n\n\n2. 映射类型（Mapped Types）#\n\n通过遍历已有类型的属性，进行转换或筛选，构造新的类型。\n\n基本映射类型#\n\n\n\n结合条件类型进行筛选#\n\n\n\n使用 keyof 和索引访问#\n\n\n\n\n3. 模板字面量类型（Template Literal Types）#\n\nTypeScript 4.1 引入了模板字面量类型，允许通过字符串字面量的组合来构造新的类型。\n\n\n\n\n4. 递归类型#\n\nTypeScript 支持递归类型定义，允许类型在自身内部引用自己，用于处理嵌套结构。\n\n\n\n--------------------------------------------------------------------------------\n\n\n三、组合使用工具类型与高级技巧#\n\n在实际开发中，往往需要组合使用内置的工具类型与高级的类型操作技巧，以实现更复杂的类型合成需求。\n\n\n示例 1：从对象类型中提取特定类型的属性#\n\n假设有一个对象类型，想要提取所有属性值为 string 类型的属性。\n\n\n\n\n示例 2：合并多个类型#\n\n假设有多个类型，想要将它们的属性合并成一个新的类型，同时处理属性冲突（如使用联合类型）。\n\n\n\n如果需要更复杂的合并策略（如联合类型），可以进一步定制：\n\n\n\n\n示例 3：提取函数返回类型并组合#\n\n假设有多个函数类型，想要提取它们的返回类型，并组合成一个新的联合类型。\n\n\n\n对于多个函数，可以定义一个工具类型：\n\n\n\n--------------------------------------------------------------------------------\n\n\n四、实用技巧与最佳实践#\n\n\n1. 使用 as 进行键的重映射#\n\n在映射类型中，可以使用 as 子句对键进行重映射，实现更灵活的类型转换。\n\n\n\n\n2. 过滤掉某些属性#\n\n结合条件类型与映射类型，可以过滤掉不需要的属性。\n\n\n\n\n3. 动态生成类型#\n\n利用泛型和条件类型，可以根据输入动态生成新的类型。\n\n\n\n--------------------------------------------------------------------------------\n\n\n五、总结#\n\nTypeScript 提供了丰富的内置工具类型和强大的类型操作能力，允许开发者从已有类型中提取、转换和组合出新的类型。以下是主要的方法汇总：\n\n 1. 内置工具类型\n    \n    * Partial, Required, Readonly\n    * Record, Pick, Omit\n    * Exclude, Extract, NonNullable\n    * ReturnType, Parameters, ConstructorParameters\n    * 字符串转换工具类型：Uppercase, Lowercase, Capitalize, Uncapitalize\n\n 2. 高级类型操作\n    \n    * 条件类型与 infer 关键字\n    * 映射类型与键的重映射 (as)\n    * 索引访问类型 (T[K])\n    * 模板字面量类型\n    * 递归类型定义\n\n 3. 组合与实用技巧\n    \n    * 组合多个工具类型实现复杂类型转换\n    * 使用 as 进行键的重命名\n    * 动态生成类型基于输入\n    * 过滤和筛选特定类型的属性\n\n掌握这些方法，可以极大地提升 TypeScript 的类型安全性与代码的可维护性，使得类型系统成为开发中的强大助手，而不仅仅是约束工具。","routePath":"/typescript/第一章 类型技巧/1.类型提取与组合","lang":"","toc":[{"text":"一、使用内置的工具类型（Utility Types）","id":"一使用内置的工具类型utility-types","depth":2,"charIndex":264},{"text":"1. `Partial<T>`","id":"1-partialt","depth":3,"charIndex":-1},{"text":"2. `Required<T>`","id":"2-requiredt","depth":3,"charIndex":-1},{"text":"3. `Readonly<T>`","id":"3-readonlyt","depth":3,"charIndex":-1},{"text":"4. `Record<K, T>`","id":"4-recordk-t","depth":3,"charIndex":-1},{"text":"5. `Pick<T, K>`","id":"5-pickt-k","depth":3,"charIndex":-1},{"text":"6. `Omit<T, K>`","id":"6-omitt-k","depth":3,"charIndex":-1},{"text":"7. `Exclude<T, U>`","id":"7-excludet-u","depth":3,"charIndex":-1},{"text":"8. `Extract<T, U>`","id":"8-extractt-u","depth":3,"charIndex":-1},{"text":"9. `NonNullable<T>`","id":"9-nonnullablet","depth":3,"charIndex":-1},{"text":"10. `ReturnType<T>`","id":"10-returntypet","depth":3,"charIndex":-1},{"text":"11. `Parameters<T>`","id":"11-parameterst","depth":3,"charIndex":-1},{"text":"12. `ConstructorParameters<T>`","id":"12-constructorparameterst","depth":3,"charIndex":-1},{"text":"13. `Uppercase<T>`, `Lowercase<T>`, `Capitalize<T>`, `Uncapitalize<T>`","id":"13-uppercaset-lowercaset-capitalizet-uncapitalizet","depth":3,"charIndex":-1},{"text":"二、高级类型操作技巧","id":"二高级类型操作技巧","depth":2,"charIndex":1076},{"text":"1. 条件类型（Conditional Types）","id":"1-条件类型conditional-types","depth":3,"charIndex":1153},{"text":"常见应用：`infer` 关键字","id":"常见应用infer-关键字","depth":4,"charIndex":-1},{"text":"2. 映射类型（Mapped Types）","id":"2-映射类型mapped-types","depth":3,"charIndex":1270},{"text":"基本映射类型","id":"基本映射类型","depth":4,"charIndex":1323},{"text":"结合条件类型进行筛选","id":"结合条件类型进行筛选","depth":4,"charIndex":1334},{"text":"使用 `keyof` 和索引访问","id":"使用-keyof-和索引访问","depth":4,"charIndex":-1},{"text":"3. 模板字面量类型（Template Literal Types）","id":"3-模板字面量类型template-literal-types","depth":3,"charIndex":1369},{"text":"4. 递归类型","id":"4-递归类型","depth":3,"charIndex":1458},{"text":"三、组合使用工具类型与高级技巧","id":"三组合使用工具类型与高级技巧","depth":2,"charIndex":1598},{"text":"示例 1：从对象类型中提取特定类型的属性","id":"示例-1从对象类型中提取特定类型的属性","depth":3,"charIndex":1666},{"text":"示例 2：合并多个类型","id":"示例-2合并多个类型","depth":3,"charIndex":1728},{"text":"示例 3：提取函数返回类型并组合","id":"示例-3提取函数返回类型并组合","depth":3,"charIndex":1823},{"text":"四、实用技巧与最佳实践","id":"四实用技巧与最佳实践","depth":2,"charIndex":1986},{"text":"1. 使用 `as` 进行键的重映射","id":"1-使用-as-进行键的重映射","depth":3,"charIndex":-1},{"text":"2. 过滤掉某些属性","id":"2-过滤掉某些属性","depth":3,"charIndex":2061},{"text":"3. 动态生成类型","id":"3-动态生成类型","depth":3,"charIndex":2103},{"text":"五、总结","id":"五总结","depth":2,"charIndex":2227}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"","content":"TypeScript 的类型系统非常强大，除了前面提到的内置工具类型和高级类型操作技巧外，还有一些更深入、更灵活的类型编程方法，包括分布式条件类型、类型推断与\ninfer 的高级用法、递归类型的高级应用、类型守卫与类型断言的结合，以及一些实用但较少被提及的技巧。\n\n--------------------------------------------------------------------------------\n\n\n六、更深入的类型编程技巧#\n\n\n1. 分布式条件类型（Distributive Conditional Types）#\n\n当条件类型作用于联合类型时，TypeScript 会自动将条件类型\"分配\"到联合类型的每个成员上，这就是分布式条件类型。\n\n基本示例#\n\n\n\n * ToArray<string | number> 会被拆解为 string[] | number[]，因为 T 是联合类型 string |\n   number，条件类型会分别应用于 string 和 number。\n\n关闭分布式行为#\n\n如果不想让条件类型自动分配，可以用[]包裹T：\n\n\n\n * [T] extends [any] 使得 T 不再被视为联合类型，而是作为一个整体处理。\n\n实际应用#\n\n\n\n * Filter 会从联合类型中筛选出符合 U 的类型。\n\n--------------------------------------------------------------------------------\n\n\n2. infer 的高级用法#\n\ninfer 不仅可以用于函数返回类型推断，还可以用于更复杂的类型结构，如：\n\n * 推断函数参数类型\n * 推断数组元素类型\n * 推断对象属性类型\n\n(1) 推断函数参数类型#\n\n\n\n(2) 推断数组元素类型#\n\n\n\n(3) 推断 Promise 的解析类型#\n\n\n\n(4) 推断对象属性类型#\n\n\n\n--------------------------------------------------------------------------------\n\n\n3. 递归类型的高级应用#\n\n递归类型不仅可以用于深度 Partial 或 DeepReadonly，还可以用于：\n\n * 递归遍历对象属性\n * 递归转换类型\n * 递归生成复杂类型\n\n(1) 递归 DeepPartial（前面已讲）#\n\n\n\n(2) 递归 DeepReadonly#\n\n\n\n(3) 递归 DeepRequired#\n\n\n\n * -? 表示移除可选修饰符，使属性变为必选。\n\n(4) 递归 DeepNullable#\n\n\n\n(5) 递归 Flatten（扁平化嵌套数组）#\n\n\n\n(6) 递归 TupleToUnion（元组转联合类型）#\n\n\n\n--------------------------------------------------------------------------------\n\n\n4. 类型守卫与类型断言的结合#\n\nTypeScript 的类型守卫（typeof、instanceof、in）可以与类型断言结合，实现更灵活的类型控制。\n\n(1) 自定义类型守卫#\n\n\n\n(2) 类型断言 + 类型守卫#\n\n\n\n--------------------------------------------------------------------------------\n\n\n5. 实用但较少被提及的技巧#\n\n(1) typeof 类型查询#\n\n\n\n(2) keyof + typeof 组合#\n\n\n\n(3) satisfies 运算符（TypeScript 4.9+）#\n\n\n\n * satisfies 确保对象符合类型，但不会改变对象的类型推断。\n\n(4) const 断言#\n\n\n\n--------------------------------------------------------------------------------\n\n\n七、总结#\n\nTypeScript 的类型系统非常灵活，除了内置工具类型和基础高级技巧外，还可以通过：\n\n 1. 分布式条件类型 处理联合类型\n 2. infer 高级推断 提取复杂类型\n 3. 递归类型 处理嵌套结构\n 4. 类型守卫 + 类型断言 实现运行时类型安全\n 5. typeof + keyof 组合 动态获取类型\n 6. satisfies 和 const 断言 增强类型安全性\n\n这些技巧可以组合使用，构建出极其强大且类型安全的 TypeScript 代码。掌握它们，可以让你写出更健壮、更易维护的 TypeScript 项目！ 🚀","routePath":"/typescript/第一章 类型技巧/2.不常见技巧","lang":"","toc":[{"text":"**六、更深入的类型编程技巧**","id":"六更深入的类型编程技巧","depth":2,"charIndex":-1},{"text":"**1. 分布式条件类型（Distributive Conditional Types）**","id":"1-分布式条件类型distributive-conditional-types","depth":3,"charIndex":-1},{"text":"**基本示例**","id":"基本示例","depth":4,"charIndex":-1},{"text":"**关闭分布式行为**","id":"关闭分布式行为","depth":4,"charIndex":-1},{"text":"**实际应用**","id":"实际应用","depth":4,"charIndex":-1},{"text":"**2. **","id":"2-","depth":3,"charIndex":-1},{"text":"**(1) 推断函数参数类型**","id":"1-推断函数参数类型","depth":4,"charIndex":-1},{"text":"**(2) 推断数组元素类型**","id":"2-推断数组元素类型","depth":4,"charIndex":-1},{"text":"**(3) 推断 Promise 的解析类型**","id":"3-推断-promise-的解析类型","depth":4,"charIndex":-1},{"text":"**(4) 推断对象属性类型**","id":"4-推断对象属性类型","depth":4,"charIndex":-1},{"text":"**3. 递归类型的高级应用**","id":"3-递归类型的高级应用","depth":3,"charIndex":-1},{"text":"**(1) 递归 **","id":"1-递归-","depth":4,"charIndex":-1},{"text":"**(2) 递归 **","id":"2-递归-","depth":4,"charIndex":-1},{"text":"**(3) 递归 **","id":"3-递归-","depth":4,"charIndex":-1},{"text":"**(4) 递归 **","id":"4-递归-","depth":4,"charIndex":-1},{"text":"**(5) 递归 **","id":"5-递归-","depth":4,"charIndex":-1},{"text":"**(6) 递归 **","id":"6-递归-","depth":4,"charIndex":-1},{"text":"**4. 类型守卫与类型断言的结合**","id":"4-类型守卫与类型断言的结合","depth":3,"charIndex":-1},{"text":"**(1) 自定义类型守卫**","id":"1-自定义类型守卫","depth":4,"charIndex":-1},{"text":"**(2) 类型断言 + 类型守卫**","id":"2-类型断言--类型守卫","depth":4,"charIndex":-1},{"text":"**5. 实用但较少被提及的技巧**","id":"5-实用但较少被提及的技巧","depth":3,"charIndex":-1},{"text":"**(1) **","id":"1-","depth":4,"charIndex":-1},{"text":"**(2) **","id":"2--1","depth":4,"charIndex":-1},{"text":"**(3) **","id":"3-","depth":4,"charIndex":-1},{"text":"**(4) **","id":"4-","depth":4,"charIndex":-1},{"text":"**七、总结**","id":"七总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""}]