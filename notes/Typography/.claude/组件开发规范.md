# Typography 组件开发规范

## 一、组件设计原则

### 1.1 核心原则
- **单一职责**：每个组件只负责一个明确的功能
- **可复用性**：组件设计考虑多种使用场景
- **可组合性**：组件可以灵活组合使用
- **静态渲染**：组件在构建时完成渲染，无运行时依赖
- **类型安全**：提供完整的 TypeScript 类型定义

### 1.2 设计思维
```typescript
// ✅ 好的设计：职责明确
interface TableProps {
  data: Array<Record<string, any>>;
  columns: Array<ColumnConfig>;
  sortable?: boolean;
}

// ❌ 避免：职责混乱
interface TableProps {
  data: Array<Record<string, any>>;
  columns: Array<ColumnConfig>;
  apiEndpoint?: string;      // 混合了数据获取逻辑
  theme?: 'light' | 'dark';  // 混合了样式逻辑
}
```

## 二、组件结构规范

### 2.1 目录结构
```
packages/components/src/
├── MyTable/                 # 组件目录
│   ├── src/
│   │   ├── index.ts         # 组件入口
│   │   ├── types.ts         # 类型定义
│   │   ├── utils.ts         # 工具函数
│   │   └── styles.scss      # 组件样式
│   ├── __tests__/           # 测试文件
│   │   ├── component.test.ts
│   │   └── utils.test.ts
│   ├── stories/             # Storybook 故事
│   │   ├── Basic.stories.ts
│   │   └── Advanced.stories.ts
│   └── index.ts             # 导出入口
```

### 2.2 组件文件结构

**主组件文件 (index.ts)**
```typescript
import { defineComponent } from 'vue';
import type { MyTableProps, MyTableEmits } from './types';
import './styles.scss';

export default defineComponent({
  name: 'MyTable',

  props: {
    // Props 定义
  } as const,

  emits: {
    // Emits 定义
  } as const,

  setup(props, { emit, slots }) {
    // 组件逻辑
    return {};
  },

  render() {
    // 渲染函数或模板
  }
});

export type { MyTableProps, MyTableEmits };
```

**类型定义文件 (types.ts)**
```typescript
export interface ColumnConfig {
  key: string;
  title: string;
  width?: number | string;
  sortable?: boolean;
  render?: (value: any, record: Record<string, any>) => any;
}

export interface MyTableProps {
  data: Array<Record<string, any>>;
  columns: Array<ColumnConfig>;
  rowKey?: string | ((record: Record<string, any>) => string);
  bordered?: boolean;
  size?: 'small' | 'middle' | 'large';
}

export interface MyTableEmits {
  sort: [column: string, direction: 'asc' | 'desc'];
  rowClick: [record: Record<string, any>, index: number];
}
```

## 三、组件开发模板

### 3.1 基础组件模板

```vue
<template>
  <div :class="tableClasses" :style="tableStyles">
    <!-- 表格头部 -->
    <div v-if="showHeader" class="my-table-header">
      <div
        v-for="column in columns"
        :key="column.key"
        :class="headerCellClasses(column)"
        :style="getColumnStyle(column)"
        @click="handleSort(column)"
      >
        {{ column.title }}
        <span v-if="getSortDirection(column.key)" class="sort-icon">
          {{ getSortDirection(column.key) === 'asc' ? '↑' : '↓' }}
        </span>
      </div>
    </div>

    <!-- 表格主体 -->
    <div class="my-table-body">
      <div
        v-for="(record, index) in data"
        :key="getRowKey(record, index)"
        :class="rowClasses(record, index)"
        @click="handleRowClick(record, index)"
      >
        <div
          v-for="column in columns"
          :key="column.key"
          :class="cellClasses(column)"
          :style="getColumnStyle(column)"
        >
          {{ getCellValue(record, column) }}
        </div>
      </div>
    </div>

    <!-- 空状态 -->
    <div v-if="data.length === 0" class="my-table-empty">
      <slot name="empty">
        {{ emptyText }}
      </slot>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import type { MyTableProps, MyTableEmits } from './types';

// Props 和 Emits 定义
interface Props extends MyTableProps {}

const props = withDefaults(defineProps<Props>(), {
  rowKey: 'id',
  bordered: false,
  size: 'middle',
  showHeader: true,
  emptyText: '暂无数据'
});

interface Emits extends MyTableEmits {}

const emit = defineEmits<Emits>();

// 响应式状态
const sortColumn = ref<string>('');
const sortDirection = ref<'asc' | 'desc'>('asc');

// 计算属性
const tableClasses = computed(() => [
  'my-table',
  `my-table--${props.size}`,
  {
    'my-table--bordered': props.bordered
  }
]);

const tableStyles = computed(() => ({
  // 样式计算
}));

// 方法
const getRowKey = (record: Record<string, any>, index: number): string => {
  if (typeof props.rowKey === 'function') {
    return props.rowKey(record);
  }
  return record[props.rowKey] || index.toString();
};

const getColumnStyle = (column: ColumnConfig) => ({
  width: column.width ? `${column.width}px` : undefined
});

const getCellValue = (record: Record<string, any>, column: ColumnConfig) => {
  if (column.render) {
    return column.render(record[column.key], record);
  }
  return record[column.key];
};

const handleSort = (column: ColumnConfig) => {
  if (!column.sortable) return;

  if (sortColumn.value === column.key) {
    sortDirection.value = sortDirection.value === 'asc' ? 'desc' : 'asc';
  } else {
    sortColumn.value = column.key;
    sortDirection.value = 'asc';
  }

  emit('sort', column.key, sortDirection.value);
};

const handleRowClick = (record: Record<string, any>, index: number) => {
  emit('rowClick', record, index);
};

// 工具函数
const headerCellClasses = (column: ColumnConfig) => [
  'my-table-header-cell',
  {
    'my-table-header-cell--sortable': column.sortable,
    'my-table-header-cell--sorted': sortColumn.value === column.key
  }
];

const rowClasses = (record: Record<string, any>, index: number) => [
  'my-table-row',
  `my-table-row--${index % 2 === 0 ? 'even' : 'odd'}`,
  {
    'my-table-row--clickable': !!emit.rowClick
  }
];

const cellClasses = (column: ColumnConfig) => [
  'my-table-cell',
  `my-table-cell--${column.key}`
];
</script>

<style lang="scss">
.my-table {
  width: 100%;
  border: 1px solid #e8e8e8;
  border-radius: 4px;
  overflow: hidden;

  &--bordered {
    .my-table-row {
      border-bottom: 1px solid #e8e8e8;
    }
  }

  &--small {
    font-size: 12px;
  }

  &--middle {
    font-size: 14px;
  }

  &--large {
    font-size: 16px;
  }
}

.my-table-header {
  background-color: #fafafa;
  font-weight: 500;
}

.my-table-header-cell {
  padding: 12px 16px;
  border-right: 1px solid #e8e8e8;

  &:last-child {
    border-right: none;
  }

  &--sortable {
    cursor: pointer;
    user-select: none;

    &:hover {
      background-color: #f0f0f0;
    }
  }

  &--sorted {
    background-color: #e6f7ff;
  }
}

.my-table-row {
  display: flex;
  transition: background-color 0.2s;

  &:hover {
    background-color: #fafafa;
  }

  &--clickable {
    cursor: pointer;
  }
}

.my-table-cell {
  padding: 12px 16px;
  border-right: 1px solid #e8e8e8;

  &:last-child {
    border-right: none;
  }
}

.my-table-empty {
  padding: 32px;
  text-align: center;
  color: #999;
}

.sort-icon {
  margin-left: 8px;
  font-size: 12px;
}
</style>
```

## 四、组件测试规范

### 4.1 测试结构

```typescript
// MyTable.test.ts
import { mount } from '@vue/test-utils';
import { describe, it, expect, beforeEach } from 'vitest';
import MyTable from '../src';
import type { MyTableProps } from '../src/types';

describe('MyTable', () => {
  let mockData: Array<Record<string, any>>;
  let mockColumns: Array<ColumnConfig>;

  beforeEach(() => {
    mockData = [
      { id: 1, name: 'John', age: 25, active: true },
      { id: 2, name: 'Jane', age: 30, active: false }
    ];

    mockColumns = [
      { key: 'name', title: 'Name' },
      { key: 'age', title: 'Age' },
      { key: 'active', title: 'Status' }
    ];
  });

  describe('基础渲染', () => {
    it('应该正确渲染表格数据', () => {
      const wrapper = mount(MyTable, {
        props: {
          data: mockData,
          columns: mockColumns
        } as MyTableProps
      });

      const rows = wrapper.findAll('.my-table-row');
      expect(rows).toHaveLength(2);

      expect(wrapper.text()).toContain('John');
      expect(wrapper.text()).toContain('Jane');
    });

    it('应该正确渲染表头', () => {
      const wrapper = mount(MyTable, {
        props: {
          data: mockData,
          columns: mockColumns
        } as MyTableProps
      });

      const headerCells = wrapper.findAll('.my-table-header-cell');
      expect(headerCells).toHaveLength(3);
      expect(headerCells[0].text()).toBe('Name');
      expect(headerCells[1].text()).toBe('Age');
      expect(headerCells[2].text()).toBe('Status');
    });
  });

  describe('Props 测试', () => {
    it('应该支持 bordered 属性', () => {
      const wrapper = mount(MyTable, {
        props: {
          data: mockData,
          columns: mockColumns,
          bordered: true
        } as MyTableProps
      });

      expect(wrapper.find('.my-table--bordered').exists()).toBe(true);
    });

    it('应该支持不同的尺寸', () => {
      const wrapper = mount(MyTable, {
        props: {
          data: mockData,
          columns: mockColumns,
          size: 'large'
        } as MyTableProps
      });

      expect(wrapper.find('.my-table--large').exists()).toBe(true);
    });
  });

  describe('事件测试', () => {
    it('应该在点击行时触发 rowClick 事件', async () => {
      const wrapper = mount(MyTable, {
        props: {
          data: mockData,
          columns: mockColumns
        } as MyTableProps
      });

      const firstRow = wrapper.find('.my-table-row');
      await firstRow.trigger('click');

      expect(wrapper.emitted('rowClick')).toBeTruthy();
      expect(wrapper.emitted('rowClick')[0]).toEqual([mockData[0], 0]);
    });

    it('应该在点击排序列时触发 sort 事件', async () => {
      const sortableColumns = [
        { key: 'name', title: 'Name', sortable: true }
      ];

      const wrapper = mount(MyTable, {
        props: {
          data: mockData,
          columns: sortableColumns
        } as MyTableProps
      });

      const headerCell = wrapper.find('.my-table-header-cell--sortable');
      await headerCell.trigger('click');

      expect(wrapper.emitted('sort')).toBeTruthy();
      expect(wrapper.emitted('sort')[0]).toEqual(['name', 'asc']);
    });
  });

  describe('插槽测试', () => {
    it('应该支持自定义空状态', () => {
      const wrapper = mount(MyTable, {
        props: {
          data: [],
          columns: mockColumns
        } as MyTableProps,
        slots: {
          empty: '<div class="custom-empty">No data available</div>'
        }
      });

      expect(wrapper.find('.custom-empty').exists()).toBe(true);
      expect(wrapper.text()).toContain('No data available');
    });
  });
});
```

### 4.2 故事文件 (Storybook)

```typescript
// Basic.stories.ts
import type { Meta, StoryObj } from '@storybook/vue3';
import MyTable from '../src';
import type { MyTableProps } from '../src/types';

const meta: Meta<typeof MyTable> = {
  title: 'Components/MyTable',
  component: MyTable,
  parameters: {
    layout: 'centered'
  },
  argTypes: {
    size: {
      control: { type: 'select' },
      options: ['small', 'middle', 'large']
    },
    bordered: {
      control: { type: 'boolean' }
    }
  }
};

export default meta;
type Story = StoryObj<typeof meta>;

const mockData = [
  { id: 1, name: 'John Doe', age: 25, email: 'john@example.com' },
  { id: 2, name: 'Jane Smith', age: 30, email: 'jane@example.com' },
  { id: 3, name: 'Bob Johnson', age: 35, email: 'bob@example.com' }
];

const mockColumns = [
  { key: 'name', title: 'Name' },
  { key: 'age', title: 'Age' },
  { key: 'email', title: 'Email' }
];

export const Default: Story = {
  args: {
    data: mockData,
    columns: mockColumns
  }
};

export const Bordered: Story = {
  args: {
    data: mockData,
    columns: mockColumns,
    bordered: true
  }
};

export const Small: Story = {
  args: {
    data: mockData,
    columns: mockColumns,
    size: 'small'
  }
};

export const WithSorting: Story = {
  args: {
    data: mockData,
    columns: mockColumns.map(col => ({ ...col, sortable: true }))
  }
};

export const Empty: Story = {
  args: {
    data: [],
    columns: mockColumns
  }
};
```

## 五、性能优化

### 5.1 渲染优化
```typescript
// ✅ 使用计算属性缓存计算结果
const processedData = computed(() => {
  return props.data.map(item => ({
    ...item,
    processed: expensiveOperation(item)
  }));
});

// ✅ 使用 shallowRef 减少响应式开销
const largeData = shallowRef<LargeData[]>([]);

// ✅ 避免在 render 中进行复杂计算
const memoizedValue = useMemo(() => {
  return heavyComputation(props.data);
}, [props.data]);
```

### 5.2 内存优化
```typescript
// ✅ 及时清理事件监听器
onUnmounted(() => {
  // 清理定时器、事件监听器等
});

// ✅ 使用 WeakMap 存储临时数据
const cache = new WeakMap<object, ProcessedData>();
```

## 六、文档规范

### 6.1 API 文档
```typescript
/**
 * MyTable 组件
 *
 * @example
 * ```vue
 * <MyTable
 *   :data="tableData"
 *   :columns="columns"
 *   @row-click="handleRowClick"
 * />
 * ```
 */
export interface MyTableProps {
  /** 表格数据 */
  data: Array<Record<string, any>>;

  /** 表格列配置 */
  columns: Array<ColumnConfig>;

  /** 是否显示边框 */
  bordered?: boolean;

  /** 表格尺寸 */
  size?: 'small' | 'middle' | 'large';
}
```

### 6.2 使用示例
```typescript
/**
 * 基础使用
 *
 * @example
 * ```typescript
 * import { MyTable } from '@typography/components';
 *
 * const data = [
 *   { id: 1, name: 'John', age: 25 },
 *   { id: 2, name: 'Jane', age: 30 }
 * ];
 *
 * const columns = [
 *   { key: 'name', title: 'Name' },
 *   { key: 'age', title: 'Age' }
 * ];
 * ```
 */
```

## 七、发布和维护

### 7.1 版本管理
```typescript
// package.json
{
  "name": "@typography/components",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./style.css": "./dist/style.css"
  }
}
```

### 7.2 变更日志
```markdown
# @typography/components

## 1.1.0 (2024-01-15)

### 新增
- 添加 MyTable 组件排序功能
- 支持自定义单元格渲染器

### 修复
- 修复表格边框样式问题
- 解决空状态显示异常

### 改进
- 优化大数据量渲染性能
- 改进 TypeScript 类型定义
```

遵循这些组件开发规范将确保组件的质量、可维护性和用户体验。