# 类型收窄

## 介绍

想象我们有一个名为 `padLeft` 的函数：

```typescript
function padLeft(padding: number | string, input: string): string {
  throw new Error("Not implemented yet!");
}
```

如果 `padding` 是数字，它将被视为我们想要添加到 `input` 前面的空格数。如果 `padding` 是字符串，它应该直接将 `padding` 添加到 `input` 前面。

让我们尝试实现当 `padding` 是数字时的逻辑：

```typescript
function padLeft(padding: number | string, input: string): string {
  return " ".repeat(padding) + input;
}
```

我们会得到一个错误：
```
Argument of type 'string | number' is not assignable to parameter of type 'number'.
Type 'string' is not assignable to type 'number'.
```

TypeScript 警告我们正在将一个类型为 `number | string` 的值传递给 `repeat` 函数，而该函数只接受 `number` 类型，这是正确的。

换句话说，我们还没有显式检查 `padding` 是否为数字，也没有处理它是字符串的情况，所以让我们这样做：

```typescript
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }
  return padding + input;
}
```

这看起来像是普通的 JavaScript 代码，这正是重点所在。除了我们添加的注解外，这段 TypeScript 代码看起来就像 JavaScript。TypeScript 的类型系统旨在尽可能轻松地编写典型的 JavaScript 代码，而无需费力获得类型安全。

## 类型收窄的工作原理

就像 TypeScript 使用静态类型分析运行时值一样，它在 JavaScript 的运行时控制流结构（如 if/else、条件三元运算符、循环、真值检查等）上覆盖了类型分析，这些结构都会影响类型。

在我们的 if 检查中，TypeScript 看到 `typeof padding === "number"` 并将其理解为一个称为**类型保护**的特殊代码形式。TypeScript 跟踪程序可能执行的路径，以分析在给定位置值的最具体可能类型。它查看这些特殊检查（称为类型保护）和赋值，将类型精炼为比声明更具体的类型的过程称为**收窄**。

在许多编辑器中，我们可以观察这些类型的变化：

```typescript
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
    // (parameter) padding: number
  }
  return padding + input;
  // (parameter) padding: string
}
```

## 不同类型的收窄构造

### typeof 类型保护

正如我们所看到的，JavaScript 支持 `typeof` 运算符，它可以在运行时提供关于值类型的基本信息。TypeScript 期望它返回一组特定的字符串：

- `"string"`
- `"number"`
- `"bigint"`
- `"boolean"`
- `"symbol"`
- `"undefined"`
- `"object"`
- `"function"`

在 TypeScript 中，检查 `typeof` 返回的值是一种类型保护。因为 TypeScript 编码了 `typeof` 在不同值上的操作方式，所以它知道 JavaScript 中的一些怪癖。

例如，注意在上面的列表中，`typeof` 不返回字符串 `"null"`。查看以下示例：

```typescript
function printAll(strs: string | string[] | null) {
  if (typeof strs === "object") {
    for (const s of strs) {
      // 'strs' is possibly 'null'.
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  } else {
    // do nothing
  }
}
```

在 JavaScript 中，`typeof null` 实际上是 `"object"`！这是历史上不幸的事故之一。幸运的是，TypeScript 让我们知道 `strs` 只被收窄到 `string[] | null` 而不是 `string[]`。

### 真值收窄

真值可能不是你在字典中找到的词，但在 JavaScript 中你会经常听到它。

在 JavaScript 中，我们可以在条件语句、`&&`、`||`、if 语句、布尔否定（`!`）等中使用任何表达式。例如，if 语句不期望它们的条件总是布尔类型。

```typescript
function getUsersOnlineMessage(numUsersOnline: number) {
  if (numUsersOnline) {
    return `There are ${numUsersOnline} online now!`;
  }
  return "Nobody's here. :(";
}
```

在 JavaScript 中，像 `if` 这样的构造首先将其条件"强制"转换为布尔值以理解它们，然后根据结果是 true 还是 false 选择分支。

以下值强制转换为 `false`：
- `0`
- `NaN`
- `""`（空字符串）
- `0n`（零的 bigint 版本）
- `null`
- `undefined`

其他值强制转换为 `true`。你总是可以通过 `Boolean` 函数或使用更短的双重布尔否定将值强制转换为布尔值。

```typescript
// both of these result in 'true'
Boolean("hello"); // type: boolean, value: true
!!"world";        // type: true, value: true
```

利用这种行为相当流行，特别是用于防范 `null` 或 `undefined` 等值。让我们尝试将其用于我们的 `printAll` 函数：

```typescript
function printAll(strs: string | string[] | null) {
  if (strs && typeof strs === "object") {
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  }
}
```

通过检查 `strs` 是否为真值，我们消除了上面的错误。这至少可以防止我们在运行代码时出现可怕的错误，如：`TypeError: null is not iterable`。

但请注意，对基本类型进行真值检查通常容易出错。例如，考虑编写 `printAll` 的不同尝试：

```typescript
function printAll(strs: string | string[] | null) {
  // DON'T DO THIS! KEEP READING
  if (strs) {
    if (typeof strs === "object") {
      for (const s of strs) {
        console.log(s);
      }
    } else if (typeof strs === "string") {
      console.log(strs);
    }
  }
}
```

我们将整个函数体包装在真值检查中，但这有一个微妙的缺点：我们可能不再正确处理空字符串情况。

关于真值收窄的最后一点是，带有 `!` 的布尔否定会从否定分支中过滤掉：

```typescript
function multiplyAll(values: number[] | undefined, factor: number): number[] | undefined {
  if (!values) {
    return values;
  } else {
    return values.map((x) => x * factor);
  }
}
```

### 相等性收窄

TypeScript 还使用 `switch` 语句和相等检查如 `===`、`!==`、`==` 和 `!=` 来收窄类型。

例如：

```typescript
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // We can now call any 'string' method on 'x' or 'y'.
    x.toUpperCase();
    y.toLowerCase();
  } else {
    console.log(x); // (parameter) x: string | number
    console.log(y); // (parameter) y: string | boolean
  }
}
```

当我们检查 `x` 和 `y` 相等时，TypeScript 知道它们的类型也必须相等。由于 `string` 是 `x` 和 `y` 都可以采用的唯一共同类型，TypeScript 知道在第一个分支中 `x` 和 `y` 必须是字符串。

检查特定的字面量值（与变量相对）也有效。在真值收窄部分，我们编写了一个容易出错的 `printAll` 函数，因为它意外地没有正确处理空字符串。相反，我们可以进行特定检查来排除 `null`，TypeScript 仍然正确地从 `strs` 的类型中移除 `null`：

```typescript
function printAll(strs: string | string[] | null) {
  if (strs !== null) {
    if (typeof strs === "object") {
      for (const s of strs) {
        // (parameter) strs: string[]
        console.log(s);
      }
    } else if (typeof strs === "string") {
      // (parameter) strs: string
      console.log(strs);
    }
  }
}
```

JavaScript 的宽松相等检查 `==` 和 `!=` 也会正确收窄。检查 `== null` 不仅检查它是否 specifically 是值 `null`，还检查它是否可能是 `undefined`。同样适用于 `== undefined`：它检查值是否为 `null` 或 `undefined`。

```typescript
interface Container {
  value: number | null | undefined;
}

function multiplyValue(container: Container, factor: number) {
  // Remove both 'null' and 'undefined' from the type.
  if (container.value != null) {
    console.log(container.value); // (property) Container.value: number
    // Now we can safely multiply 'container.value'.
    container.value *= factor;
  }
}
```

### in 运算符收窄

JavaScript 有一个运算符用于确定对象或其原型链是否具有具有名称的属性：`in` 运算符。TypeScript 将其作为收窄潜在类型的一种方式。

例如，对于代码：`"value" in x`，其中 `"value"` 是字符串字面量，`x` 是联合类型。"true" 分支收窄 `x` 的类型为具有可选或必需属性 `value` 的类型，"false" 分支收窄为具有可选或缺失属性 `value` 的类型。

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    return animal.swim();
  }
  return animal.fly();
}
```

可选属性将在收窄的两侧都存在。例如，人类既可以游泳也可以飞行（有合适的装备），因此应该出现在 `in` 检查的两侧：

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };
type Human = { swim?: () => void; fly?: () => void };

function move(animal: Fish | Bird | Human) {
  if ("swim" in animal) {
    animal; // (parameter) animal: Fish | Human
  } else {
    animal; // (parameter) animal: Bird | Human
  }
}
```

### instanceof 收窄

JavaScript 有一个运算符用于检查值是否是另一个值的"实例"。更具体地说，在 JavaScript 中 `x instanceof Foo` 检查 `x` 的原型链是否包含 `Foo.prototype`。虽然我们不会深入探讨，但当你进入类时你会看到更多，它们对于大多数可以用 `new` 构造的值仍然有用。

正如你可能猜到的，`instanceof` 也是一种类型保护，TypeScript 在由 `instanceof` 保护的分支中收窄类型。

```typescript
function logValue(x: Date | string) {
  if (x instanceof Date) {
    console.log(x.toUTCString()); // (parameter) x: Date
  } else {
    console.log(x.toUpperCase()); // (parameter) x: string
  }
}
```

### 赋值

正如我们之前提到的，当我们赋值给任何变量时，TypeScript 会查看赋值的右侧并适当收窄左侧。

```typescript
let x = Math.random() < 0.5 ? 10 : "hello world!";
// let x: string | number
x = 1;
console.log(x); // let x: number
x = "goodbye!";
console.log(x); // let x: string
```

注意这些赋值都是有效的。尽管在第一次赋值后 `x` 的观察类型变为 `number`，我们仍然能够将字符串赋值给 `x`。这是因为 `x` 的声明类型（`x` 开始的类型）是 `string | number`，并且可分配性总是针对声明类型进行检查。

如果我们尝试将布尔值赋给 `x`，我们会看到错误，因为这不是声明类型的一部分。

```typescript
let x = Math.random() < 0.5 ? 10 : "hello world!";
// let x: string | number
x = 1;
console.log(x); // let x: number
x = true; // Type 'boolean' is not assignable to type 'string | number'.
console.log(x);
```

## 控制流分析

到目前为止，我们已经看了一些 TypeScript 如何在特定分支内收窄的基本示例。但还有更多事情发生，而不仅仅是从每个变量向上查找 if、while、条件语句等中的类型保护。

例如：

```typescript
function padLeft(padding: number | string, input: string) {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }
  return padding + input;
}
```

`padLeft` 从其第一个 if 块中返回。TypeScript 能够分析此代码，并看到在 `padding` 是数字的情况下，函数体的其余部分（`return padding + input;`）是不可达的。因此，它能够从 `padding` 的类型中移除 `number`（从 `string | number` 收窄到 `string`）用于函数的其余部分。

这种基于可达性的代码分析称为**控制流分析**，TypeScript 使用这种流分析在遇到类型保护和赋值时收窄类型。当分析变量时，控制流可以分裂并重新合并多次，并且可以观察到该变量在每个点具有不同的类型。

```typescript
function example() {
  let x: string | number | boolean;
  
  x = Math.random() < 0.5;
  console.log(x); // let x: boolean
  
  if (Math.random() < 0.5) {
    x = "hello";
    console.log(x); // let x: string
  } else {
    x = 100;
    console.log(x); // let x: number
  }
  
  return x; // let x: string | number
}
```

## 使用类型谓词

到目前为止，我们已经使用现有的 JavaScript 构造来处理收窄，但有时你想要更直接地控制类型在代码中的变化方式。

要定义用户定义的类型保护，我们只需要定义一个返回类型为**类型谓词**的函数：

```typescript
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}
```

`pet is Fish` 是本例中的类型谓词。谓词采用 `parameterName is Type` 的形式，其中 `parameterName` 必须是当前函数签名中的参数名称。

任何时候使用某个变量调用 `isFish`，如果原始类型兼容，TypeScript 会将该变量收窄到该特定类型。

```typescript
// Both calls to 'swim' and 'fly' are now okay.
let pet = getSmallPet();

if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}
```

请注意，TypeScript 不仅知道在 if 分支中 `pet` 是 `Fish`；它还知道在 else 分支中，你没有 `Fish`，所以你必须有一个 `Bird`。

你可以使用类型保护 `isFish` 过滤 `Fish | Bird` 的数组并获得 `Fish` 数组：

```typescript
const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];
const underWater1: Fish[] = zoo.filter(isFish);
// or, equivalently
const underWater2: Fish[] = zoo.filter(isFish) as Fish[];

// The predicate may need repeating for more complex examples
const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {
  if (pet.name === "sharkey") return false;
  return isFish(pet);
});
```

## 可辨识联合

到目前为止，我们看的大多数示例都集中在使用简单类型（如 `string`、`boolean` 和 `number`）收窄单个变量。虽然这很常见，但在 JavaScript 中大多数时候我们会处理稍微复杂的结构。

为了激励，假设我们正在尝试编码圆形和正方形等形状。圆形记录其半径，正方形记录其边长。我们将使用名为 `kind` 的字段来告诉我们正在处理哪种形状。这是定义 `Shape` 的第一次尝试：

```typescript
interface Shape {
  kind: "circle" | "square";
  radius?: number;
  sideLength?: number;
}
```

注意我们使用字符串字面量类型的联合：`"circle"` 和 `"square"` 来告诉我们是否应该将形状视为圆形或正方形。通过使用 `"circle" | "square"` 而不是 `string`，我们可以避免拼写错误问题。

```typescript
function handleShape(shape: Shape) {
  // oops!
  if (shape.kind === "rect") {
    // This comparison appears to be unintentional because the types '"circle" | "square"' and '"rect"' have no overlap.
  }
}
```

我们可以编写一个 `getArea` 函数，根据它处理的是圆形还是正方形应用正确的逻辑。我们将首先处理圆形：

```typescript
function getArea(shape: Shape) {
  return Math.PI * shape.radius ** 2;
  // 'shape.radius' is possibly 'undefined'.
}
```

在 `strictNullChecks` 下，这会给我们一个错误 - 这是适当的，因为 `radius` 可能未定义。但如果我们对 `kind` 属性执行适当的检查呢？

```typescript
function getArea(shape: Shape) {
  if (shape.kind === "circle") {
    return Math.PI * shape.radius ** 2;
    // 'shape.radius' is possibly 'undefined'.
  }
}
```

TypeScript 仍然不知道在这里该做什么。我们遇到了一个点，我们比类型检查器更了解我们的值。我们可以尝试使用非空断言（`shape.radius` 后面的 `!`）来说明 `radius` 肯定存在。

```typescript
function getArea(shape: Shape) {
  if (shape.kind === "circle") {
    return Math.PI * shape.radius! ** 2;
  }
}
```

但这并不理想。我们必须用那些非空断言（`!`）对类型检查器"喊叫"，以说服它 `shape.radius` 已定义，但如果我们开始移动代码，这些断言容易出错。此外，在 `strictNullChecks` 之外，我们仍然能够意外访问任何这些字段（因为可选属性在读取时被假定为始终存在）。我们肯定可以做得更好。

这种 `Shape` 编码的问题在于，类型检查器无法根据 `kind` 属性知道 `radius` 或 `sideLength` 是否存在。我们需要将我们知道的信息传达给类型检查器。考虑到这一点，让我们再次尝试定义 `Shape`：

```typescript
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

type Shape = Circle | Square;
```

在这里，我们正确地将 `Shape` 分离为两种类型，它们的 `kind` 属性值不同，但 `radius` 和 `sideLength` 在各自的类型中声明为必需属性。

让我们看看当我们尝试访问 `Shape` 的半径时会发生什么：

```typescript
function getArea(shape: Shape) {
  return Math.PI * shape.radius ** 2;
  // Property 'radius' does not exist on type 'Shape'. Property 'radius' does not exist on type 'Square'.
}
```

就像我们第一次定义 `Shape` 一样，这仍然是一个错误。但现在 `Shape` 是一个联合，TypeScript 告诉我们 `shape` 可能是一个 `Square`，而 `Square` 没有定义 `radius`！两种解释都是正确的，但只有 `Shape` 的联合编码会导致错误，无论 `strictNullChecks` 如何配置。

但是如果我们再次检查 `kind` 属性呢？

```typescript
function getArea(shape: Shape) {
  if (shape.kind === "circle") {
    return Math.PI * shape.radius ** 2;
    // (parameter) shape: Circle
  }
}
```

错误消失了！当联合中的每种类型都包含具有字面类型的公共属性时，TypeScript 认为这是一个**可辨识联合**，并且可以收窄联合的成员。

在这种情况下，`kind` 是那个公共属性（这被认为是 `Shape` 的**判别属性**）。检查 `kind` 属性是否为 `"circle"` 会消除 `Shape` 中没有 `kind` 属性类型为 `"circle"` 的每种类型。这将 `shape` 收窄到类型 `Circle`。

相同的检查也适用于 `switch` 语句。现在我们可以尝试编写完整的 `getArea` 而没有任何讨厌的 `!` 非空断言。

```typescript
function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
      // (parameter) shape: Circle
    case "square":
      return shape.sideLength ** 2;
      // (parameter) shape: Square
  }
}
```

这里重要的是 `Shape` 的编码。向 TypeScript 传达正确信息 - `Circle` 和 `Square` 确实是具有特定 `kind` 字段的两个独立类型 - 至关重要。这样做让我们编写类型安全的 TypeScript 代码，看起来与我们本来要编写的 JavaScript 没有什么不同。从那里，类型系统能够做"正确"的事情，并在我们的 `switch` 语句的每个分支中找出类型。

## never 类型

当收窄时，你可以将联合的选项减少到一点，在那里你已经移除了所有可能性并且没有留下任何东西。在这些情况下，TypeScript 将使用 `never` 类型来表示不应存在的状态。

## 穷尽性检查

`never` 类型可分配给每种类型；但是，没有类型可分配给 `never`（除了 `never` 本身）。这意味着你可以使用收窄并依赖 `never` 的出现来在 `switch` 语句中进行穷尽性检查。

例如，向我们的 `getArea` 函数添加一个默认情况，该情况尝试将 `shape` 分配给 `never`，当每个可能的情况都已处理时不会引发错误。

```typescript
type Shape = Circle | Square;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    default:
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}
```

向 `Shape` 联合添加新成员将导致 TypeScript 错误：

```typescript
interface Triangle {
  kind: "triangle";
  sideLength: number;
}

type Shape = Circle | Square | Triangle;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    default:
      const _exhaustiveCheck: never = shape;
      // Type 'Triangle' is not assignable to type 'never'.
      return _exhaustiveCheck;
  }
}
```