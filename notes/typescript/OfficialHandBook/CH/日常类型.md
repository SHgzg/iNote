# TypeScript 文档 - 日常类型

## 介绍

在本章中，我们将介绍 JavaScript 代码中最常见的一些值类型，并解释在 TypeScript 中描述这些类型的相应方法。这不是一个详尽的列表，未来的章节将描述更多命名和使用其他类型的方式。

类型不仅出现在类型注解中，还可以出现在更多地方。在我们学习类型本身的同时，我们还将学习可以在哪些地方引用这些类型以形成新的构造。

我们将从回顾编写 JavaScript 或 TypeScript 代码时可能遇到的最基本和最常见的类型开始。这些将构成更复杂类型的核心构建块。

## 基本类型：string、number 和 boolean

JavaScript 有三种非常常用的基本类型：`string`、`number` 和 `boolean`。每种在 TypeScript 中都有对应的类型。正如你所期望的，这些名称与你在这些类型的值上使用 JavaScript `typeof` 运算符时看到的名称相同：

- `string` 表示字符串值，如 `"Hello, world"`
- `number` 用于数字，如 `42`。JavaScript 没有用于整数的特殊运行时值，因此没有等同于 `int` 或 `float` 的类型 - 一切都只是 `number`
- `boolean` 用于两个值 `true` 和 `false`

类型名称 `String`、`Number` 和 `Boolean`（以大写字母开头）是合法的，但引用了一些特殊的内置类型，这些类型很少出现在你的代码中。始终使用 `string`、`number` 或 `boolean` 作为类型。

## 数组

要指定像 `[1, 2, 3]` 这样的数组的类型，可以使用语法 `number[]`；这种语法适用于任何类型（例如，`string[]` 是字符串数组，等等）。你也可以看到这写为 `Array<number>`，意思相同。我们将在介绍泛型时了解更多关于语法 `T<U>` 的信息。

注意 `[number]` 是不同的东西；请参考元组部分。

## any

TypeScript 还有一个特殊的类型 `any`，当你不希望某个值引起类型检查错误时，可以使用它。

当值的类型为 `any` 时，你可以访问它的任何属性（这些属性又将具有 `any` 类型），像函数一样调用它，将其赋值给（或从）任何类型的值，或者几乎任何其他语法上合法的操作：

```typescript
let obj: any = { x: 0 };
// 以下代码行都不会抛出编译器错误。
// 使用 `any` 会禁用所有进一步的类型检查，并且假定
// 你比 TypeScript 更了解环境。
obj.foo();
obj();
obj.bar = 100;
obj = "hello";
const n: number = obj;
```

当你不想写一个长的类型只是为了说服 TypeScript 某行代码没问题时，`any` 类型很有用。

### noImplicitAny

当你不指定类型，并且 TypeScript 无法从上下文中推断出类型时，编译器通常会默认为 `any`。不过，你通常希望避免这种情况，因为 `any` 不会进行类型检查。使用编译器标志 `noImplicitAny` 将任何隐式的 `any` 标记为错误。

## 变量的类型注解

当你使用 `const`、`var` 或 `let` 声明变量时，你可以选择添加类型注解以明确指定变量的类型：

```typescript
let myName: string = "Alice";
```

TypeScript 不使用 "左侧类型" 风格的声明，如 `int x = 0;`。类型注解总是放在被类型化的东西之后。

在大多数情况下，这是不需要的。只要可能，TypeScript 会尝试自动推断代码中的类型。例如，变量的类型是基于其初始化器的类型推断的：

```typescript
// 不需要类型注解 -- 'myName' 推断为类型 'string'
let myName = "Alice";
```

在大多数情况下，你不需要明确学习推断规则。如果你刚开始，尝试使用比你认为更少的类型注解 - 你可能会惊讶于 TypeScript 完全理解正在发生的事情所需的注解如此之少。

## 函数

函数是 JavaScript 中传递数据的主要方式。TypeScript 允许你指定函数的输入和输出值的类型。

### 参数类型注解

当你声明函数时，可以在每个参数后添加类型注解以声明函数接受哪些类型的参数。参数类型注解放在参数名之后：

```typescript
// 参数类型注解
function greet(name: string) {
  console.log("Hello, " + name.toUpperCase() + "!!");
}
```

当参数有类型注解时，将检查该函数的参数：

```typescript
// 如果执行，将是运行时错误！
greet(42);
// Argument of type 'number' is not assignable to parameter of type 'string'.
```

即使你的参数上没有类型注解，TypeScript 仍然会检查你是否传递了正确数量的参数。

### 返回类型注解

你也可以添加返回类型注解。返回类型注解出现在参数列表之后：

```typescript
function getFavoriteNumber(): number {
  return 26;
}
```

很像变量类型注解，你通常不需要返回类型注解，因为 TypeScript 将基于其返回语句推断函数的返回类型。上面示例中的类型注解不会改变任何东西。一些代码库会明确指定返回类型以用于文档目的，防止意外更改，或者只是个人偏好。

### 返回 Promise 的函数

如果你想注解返回 promise 的函数的返回类型，应该使用 `Promise` 类型：

```typescript
async function getFavoriteNumber(): Promise<number> {
  return 26;
}
```

### 匿名函数

匿名函数与函数声明有点不同。当函数出现在 TypeScript 可以确定它将如何被调用的地方时，该函数的参数会自动被赋予类型。

这是一个例子：

```typescript
const names = ["Alice", "Bob", "Eve"];

// 函数的上下文类型 - 参数 s 推断为具有字符串类型
names.forEach(function(s) {
  console.log(s.toUpperCase());
});

// 上下文类型也适用于箭头函数
names.forEach((s) => {
  console.log(s.toUpperCase());
});
```

尽管参数 `s` 没有类型注解，但 TypeScript 使用了 `forEach` 函数的类型以及数组的推断类型来确定 `s` 将具有的类型。

这个过程称为**上下文类型**，因为函数出现的上下文通知了它应该具有的类型。

与推断规则类似，你不需要明确学习这是如何发生的，但理解它确实发生可以帮助你注意到何时不需要类型注解。稍后，我们将看到更多关于值出现的上下文如何影响其类型的示例。

## 对象类型

除了基本类型之外，你将遇到的最常见的类型是**对象类型**。这指的是任何具有属性的 JavaScript 值，这几乎是所有值！要定义对象类型，我们只需列出其属性及其类型。

例如，这是一个接受类似点的对象的函数：

```typescript
// 参数的类型注解是一个对象类型
function printCoord(pt: { x: number; y: number }) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 3, y: 7 });
```

在这里，我们用一个具有两个属性 - `x` 和 `y` 的类型注解了参数 - 这两个属性都是 `number` 类型。你可以使用 `,` 或 `;` 分隔属性，最后的分隔符无论如何都是可选的。

每个属性的类型部分也是可选的。如果你不指定类型，它将被假定为 `any`。

### 可选属性

对象类型还可以指定其部分或全部属性是**可选的**。要做到这一点，在属性名后添加一个 `?`：

```typescript
function printName(obj: { first: string; last?: string }) {}

// 都 OK
printName({ first: "Bob" });
printName({ first: "Alice", last: "Alisson" });
```

在 JavaScript 中，如果你访问不存在的属性，你将得到值 `undefined` 而不是运行时错误。因此，当你从可选属性读取时，在使用之前必须检查 `undefined`。

```typescript
function printName(obj: { first: string; last?: string }) {
  // 错误 - 如果未提供 'obj.last' 可能会崩溃！
  console.log(obj.last.toUpperCase());
  // 'obj.last' is possibly 'undefined'.

  if (obj.last !== undefined) {
    // OK
    console.log(obj.last.toUpperCase());
  }

  // 使用现代 JavaScript 语法的安全替代方案：
  console.log(obj.last?.toUpperCase());
}
```

## 联合类型

TypeScript 的类型系统允许你使用各种运算符从现有类型构建新类型。现在我们知道如何编写一些类型，是时候开始以有趣的方式组合它们了。

### 定义联合类型

你可能看到的组合类型的第一个方式是联合类型。联合类型是由两个或多个其他类型形成的类型，表示可能是这些类型中任何一个的值。我们将这些类型中的每一个称为联合的**成员**。

让我们编写一个可以操作字符串或数字的函数：

```typescript
function printId(id: number | string) {
  console.log("Your ID is: " + id);
}

// OK
printId(101);
// OK
printId("202");
// Error
printId({ myID: 22342 });
// Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.
```

联合成员的分隔符在第一个元素之前是允许的，所以你也可以这样写：

```typescript
function printTextOrNumberOrBool(textOrNumberOrBool: | string | number | boolean) {
  console.log(textOrNumberOrBool);
}
```

### 使用联合类型

提供匹配联合类型的值很容易 - 只需提供匹配联合任何成员的类型。如果你有一个联合类型的值，你如何与之合作？TypeScript 只允许对联合的每个成员都有效的操作。

例如，如果你有联合 `string | number`，你不能使用仅在 `string` 上可用的方法：

```typescript
function printId(id: number | string) {
  console.log(id.toUpperCase());
  // Property 'toUpperCase' does not exist on type 'string | number'.
  // Property 'toUpperCase' does not exist on type 'number'.
}
```

解决方案是通过代码收窄联合，就像你在没有类型注解的 JavaScript 中那样。当 TypeScript 可以基于代码结构推断出值的更具体类型时，就会发生收窄。

例如，TypeScript 知道只有字符串值才会具有 `typeof` 值 `"string"`：

```typescript
function printId(id: number | string) {
  if (typeof id === "string") {
    // 在这个分支中，id 是 'string' 类型
    console.log(id.toUpperCase());
  } else {
    // 这里，id 是 'number' 类型
    console.log(id);
  }
}
```

另一个例子是使用像 `Array.isArray` 这样的函数：

```typescript
function welcomePeople(x: string[] | string) {
  if (Array.isArray(x)) {
    // 这里：'x' 是 'string[]'
    console.log("Hello, " + x.join(" and "));
  } else {
    // 这里：'x' 是 'string'
    console.log("Welcome lone traveler " + x);
  }
}
```

注意在 else 分支中，我们不需要做任何特殊的事情 - 如果 `x` 不是 `string[]`，那么它一定是 `string`。

有时你会有一个所有成员都有共同点的联合。例如，数组和字符串都有 `slice` 方法。如果联合中的每个成员都有一个共同的属性，你可以在不收窄的情况下使用该属性：

```typescript
// 返回类型推断为 number[] | string
function getFirstThree(x: number[] | string) {
  return x.slice(0, 3);
}
```

联合类型似乎具有这些类型属性的交集可能会令人困惑。这不是偶然的 - 名称联合来自类型理论。联合 `number | string` 是通过获取每个类型的值的联合组成的。注意，给定两个具有关于每个集合的相应事实的集合，只有这些事实的交集适用于集合本身的联合。

例如，如果我们有一个戴帽子的高个子房间，和另一个戴帽子的说西班牙语的人的房间，在组合这些房间之后，我们知道关于每个人的唯一事情是他们必须戴帽子。

## 类型别名

我们一直通过在类型注解中直接编写对象类型和联合类型来使用它们。这很方便，但通常希望多次使用相同的类型并通过单个名称引用它。

类型别名正是这样 - 任何类型的名称。类型别名的语法是：

```typescript
type Point = {
  x: number;
  y: number;
};

// 与前面的示例完全相同
function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });
```

你实际上可以使用类型别名给任何类型命名，而不仅仅是对象类型。例如，类型别名可以命名联合类型：

```typescript
type ID = number | string;
```

注意别名只是别名 - 你不能使用类型别名创建相同类型的不同/不同"版本"。当你使用别名时，完全就像你编写了别名类型一样。换句话说，这段代码可能看起来非法，但根据 TypeScript 是 OK 的，因为两种类型都是相同类型的别名：

```typescript
type UserInputSanitizedString = string;

function sanitizeInput(str: string): UserInputSanitizedString {
  return sanitize(str);
}

// 创建一个消毒的输入
let userInput = sanitizeInput(getInput());

// 但仍然可以用字符串重新分配
userInput = "new input";
```

## 接口

接口声明是命名对象类型的另一种方式：

```typescript
interface Point {
  x: number;
  y: number;
}

function printCoord(pt: Point) {
  console.log("The coordinate's x value is " + pt.x);
  console.log("The coordinate's y value is " + pt.y);
}

printCoord({ x: 100, y: 100 });
```

就像我们上面使用类型别名一样，该示例的工作原理就像我们使用了匿名对象类型一样。TypeScript 只关心我们传递给 `printCoord` 的值的结构 - 它只关心它具有预期的属性。只关心类型的结构和能力是为什么我们称 TypeScript 为结构类型系统的原因。

## 类型别名和接口之间的区别

类型别名和接口非常相似，在许多情况下你可以自由选择它们。接口的几乎所有功能在 `type` 中都可用，关键区别是 `type` 不能重新打开以添加新属性，而接口总是可扩展的。

| 接口 | 类型 |
|------|------|
| 扩展接口：<br>`interface Animal { name: string; }`<br>`interface Bear extends Animal { honey: boolean; }`<br>`const bear = getBear();`<br>`bear.name;`<br>`bear.honey;` | 通过交集扩展类型：<br>`type Animal = { name: string; }`<br>`type Bear = Animal & { honey: boolean; }`<br>`const bear = getBear();`<br>`bear.name;`<br>`bear.honey;` |
| 向现有接口添加新字段：<br>`interface Window { title: string; }`<br>`interface Window { ts: TypeScriptAPI; }`<br>`const src = 'const a = "Hello World"';`<br>`window.ts.transpileModule(src, {});` | 创建后无法更改类型：<br>`type Window = { title: string; }`<br>`type Window = { ts: TypeScriptAPI; }`<br>`// Error: Duplicate identifier 'Window'.` |

你将在后面的章节中了解更多关于这些概念的信息，所以如果你现在不理解所有这些，请不要担心。

在 TypeScript 4.2 版本之前，类型别名名称可能出现在错误消息中，有时代替等效的匿名类型（这可能可能不可取）。接口将始终在错误消息中命名。

在大多数情况下，你可以基于个人偏好进行选择，如果需要某种声明是另一种，TypeScript 会告诉你。如果你想要一个启发式方法，请使用 `interface`，直到你需要使用 `type` 的功能。

## 类型断言

有时你会拥有 TypeScript 无法知道的关于值类型的信息。例如，如果你使用 `document.getElementById`，TypeScript 只知道这将返回某种 `HTMLElement`，但你可能知道你的页面将始终具有给定 ID 的 `HTMLCanvasElement`。

在这种情况下，你可以使用类型断言来指定更具体的类型：

```typescript
const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
```

像类型注解一样，类型断言被编译器删除，不会影响代码的运行时行为。

你也可以使用尖括号语法（除非代码在 `.tsx` 文件中），这是等效的：

```typescript
const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");
```

提醒：因为类型断言在编译时被删除，所以没有与类型断言关联的运行时检查。如果类型断言错误，不会生成异常或 `null`。

TypeScript 只允许转换为类型的更具体或更不具体版本的类型断言。此规则防止"不可能"的强制转换，如：

```typescript
const x = "hello" as number;
// Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
```

有时此规则可能过于保守，并且会禁止可能有效的更复杂的强制转换。如果发生这种情况，你可以使用两个断言，首先到 `any`（或 `unknown`，我们稍后会介绍），然后到所需的类型：

```typescript
const a = expr as any as T;
```

## 字面量类型

除了通用类型 `string` 和 `number` 之外，我们还可以在类型位置引用特定的字符串和数字。

考虑这一点的一种方式是考虑 JavaScript 如何提供不同的方式来声明变量。`var` 和 `let` 都允许更改变量内部的内容，而 `const` 不允许。这反映在 TypeScript 如何为字面量创建类型中。

```typescript
let changingString = "Hello World";
changingString = "Olá Mundo";
// 因为 `changingString` 可以表示任何可能的字符串，
// 这就是 TypeScript 在类型系统中描述它的方式
changingString; // let changingString: string

const constantString = "Hello World";
// 因为 `constantString` 只能表示 1 个可能的字符串，
// 它具有字面量类型表示
constantString; // const constantString: "Hello World"
```

单独来看，字面量类型不是很有价值：

```typescript
let x: "hello" = "hello";
// OK
x = "hello";
x = "howdy";
// Type '"howdy"' is not assignable to type '"hello"'.
```

只有一个值的变量没有多大用处！但是通过将字面量组合成联合，你可以表达一个更有用的概念 - 例如，只接受某些已知值集的函数：

```typescript
function printText(s: string, alignment: "left" | "right" | "center") {}

printText("Hello, world", "left");
printText("G'day, mate", "centre");
// Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.
```

数字字面量类型的工作方式相同：

```typescript
function compare(a: string, b: string): -1 | 0 | 1 {
  return a === b ? 0 : a > b ? 1 : -1;
}
```

当然，你可以将这些与非字面量类型结合：

```typescript
interface Options {
  width: number;
}

function configure(x: Options | "auto") {}

configure({ width: 100 });
configure("auto");
configure("automatic");
// Argument of type '"automatic"' is not assignable to parameter of type 'Options | "auto"'.
```

还有另一种字面量类型：布尔字面量。只有两种布尔字面量类型，正如你可能猜到的，它们是类型 `true` 和 `false`。类型 `boolean` 本身实际上只是联合 `true | false` 的别名。

### 字面量推断

当你使用对象初始化变量时，TypeScript 假定该对象的属性可能稍后会更改值。例如，如果你编写这样的代码：

```typescript
const obj = { counter: 0 };
if (someCondition) {
  obj.counter = 1;
}
```

TypeScript 不认为将 `1` 赋值给先前具有 `0` 的字段是错误的。另一种说法是 `obj.counter` 必须具有类型 `number`，而不是 `0`，因为类型用于确定读取和写入行为。

这同样适用于字符串：

```typescript
declare function handleRequest(url: string, method: "GET" | "POST"): void;

const req = { url: "https://example.com", method: "GET" };
handleRequest(req.url, req.method);
// Argument of type 'string' is not assignable to parameter of type '"GET" | "POST"'.
```

在上面的例子中，`req.method` 被推断为 `string`，而不是 `"GET"`。因为在创建 `req` 和调用 `handleRequest` 之间可以评估代码，这可能会将新的字符串如 `"GUESS"` 分配给 `req.method`，TypeScript 认为此代码有错误。

有两种方法可以解决这个问题。你可以通过在任一位置添加类型断言来更改推断：

```typescript
// 更改 1：
const req = { url: "https://example.com", method: "GET" as "GET" };
// 更改 2
handleRequest(req.url, req.method as "GET");
```

更改 1 意味着"我打算让 `req.method` 始终具有字面量类型 `"GET"`"，防止之后可能将 `"GUESS"` 分配给该字段。更改 2 意味着"我知道其他原因 `req.method` 具有值 `"GET"`"。

你可以使用 `as const` 将整个对象转换为类型字面量：

```typescript
const req = { url: "https://example.com", method: "GET" } as const;
handleRequest(req.url, req.method);
```

`as const` 后缀就像 `const` 但对于类型系统，确保所有属性都被分配字面量类型而不是更通用的版本，如 `string` 或 `number`。

## null 和 undefined

JavaScript 有两个用于表示 absent 或未初始化值的原始值：`null` 和 `undefined`。TypeScript 有两个同名的相应类型。这些类型的行为取决于你是否打开了 `strictNullChecks` 选项。

### strictNullChecks 关闭

当 `strictNullChecks` 关闭时，可能为 `null` 或 `undefined` 的值仍然可以正常访问，并且值 `null` 和 `undefined` 可以分配给任何类型的属性。这类似于没有空检查的语言（例如 C#、Java）的行为。缺乏对这些值的检查往往是错误的主要来源；如果在其代码库中实际可行，我们总是建议人们打开 `strictNullChecks`。

### strictNullChecks 打开

当 `strictNullChecks` 打开时，当值为 `null` 或 `undefined` 时，在使用该值上的方法或属性之前，你需要测试这些值。就像在使用可选属性之前检查 `undefined` 一样，我们可以使用收窄来检查可能为 `null` 的值：

```typescript
function doSomething(x: string | null) {
  if (x === null) {
    // 什么都不做
  } else {
    console.log("Hello, " + x.toUpperCase());
  }
}
```

### 非空断言运算符（后缀 !）

TypeScript 还有一个特殊的语法，用于从类型中删除 `null` 和 `undefined`，而不进行任何显式检查。在任何表达式后写 `!` 实际上是一个类型断言，表明该值不是 `null` 或 `undefined`：

```typescript
function liveDangerously(x?: number | null) {
  // 没有错误
  console.log(x!.toFixed());
}
```

就像其他类型断言一样，这不会改变代码的运行时行为，因此重要的是只有当你知道该值不能是 `null` 或 `undefined` 时才使用 `!`。

## 枚举

枚举是 TypeScript 添加到 JavaScript 的一个功能，它允许描述一个值，该值可能是一组可能的命名常量之一。与大多数 TypeScript 功能不同，这不是对 JavaScript 的类型级添加，而是添加到语言和运行时中的东西。因此，这是一个你应该知道存在的功能，但可能推迟使用，除非你确定。你可以在枚举参考页面中阅读更多关于枚举的信息。

## 不太常见的原始类型

值得一提的是 JavaScript 中在类型系统中表示的其他原始类型。虽然我们不会在这里深入探讨。

### bigint

从 ES2020 开始，JavaScript 中有一个用于非常大整数的原始类型 `BigInt`：

```typescript
// 通过 BigInt 函数创建 bigint
const oneHundred: bigint = BigInt(100);

// 通过字面量语法创建 BigInt
const anotherHundred: bigint = 100n;
```

### symbol

JavaScript 中有一个原始类型，用于通过函数 `Symbol()` 创建全局唯一引用：

```typescript
const firstName = Symbol("name");
const secondName = Symbol("name");

if (firstName === secondName) {
  // This comparison appears to be unintentional because the types 'typeof firstName' and 'typeof secondName' have no overlap.
  // 永远不会发生
}
```