# TypeScript 文档 - 更多关于函数的内容

函数是任何应用程序的基本构建块，无论它们是本地函数、从另一个模块导入的函数，还是类上的方法。它们也是值，就像其他值一样，TypeScript 有很多方法来描述如何调用函数。让我们学习如何编写描述函数的类型。

## 函数类型表达式

描述函数的最简单方法是使用函数类型表达式。这些类型在语法上类似于箭头函数：

```typescript
function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}

function printToConsole(s: string) {
  console.log(s);
}

greeter(printToConsole);
```

语法 `(a: string) => void` 表示"一个具有一个参数 `a`，类型为 `string`，没有返回值的函数"。就像函数声明一样，如果没有指定参数类型，它隐式为 `any`。

注意：参数名是必需的。函数类型 `(string) => void` 表示"一个具有名为 `string` 的参数，类型为 `any` 的函数"！

当然，我们可以使用类型别名来命名函数类型：

```typescript
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) {
  // ...
}
```

## 调用签名

在 JavaScript 中，函数除了可调用外还可以具有属性。但是，函数类型表达式语法不允许声明属性。如果我们想描述具有属性的可调用对象，可以在对象类型中编写调用签名：

```typescript
type DescribableFunction = {
  description: string;
  (someArg: number): boolean;
};

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}

function myFunc(someArg: number) {
  return someArg > 3;
}

myFunc.description = "default description";
doSomething(myFunc);
```

注意：语法与函数类型表达式略有不同 - 在参数列表和返回类型之间使用 `:` 而不是 `=>`。

## 构造签名

JavaScript 函数也可以使用 `new` 操作符调用。TypeScript 将这些称为构造函数，因为它们通常创建新对象。你可以通过在调用签名前添加 `new` 关键字来编写构造签名：

```typescript
type SomeConstructor = {
  new (s: string): SomeObject;
};

function fn(ctor: SomeConstructor) {
  return new ctor("hello");
}
```

有些对象，如 JavaScript 的 `Date` 对象，可以在有或没有 `new` 的情况下调用。你可以在同一类型中任意组合调用和构造签名：

```typescript
interface CallOrConstruct {
  (n?: number): string;
  new (s: string): Date;
}

function fn(ctor: CallOrConstruct) {
  // 将类型为 `number` 的参数传递给 `ctor` 会将其与
  // `CallOrConstruct` 接口中的第一个定义匹配。
  console.log(ctor(10)); // (parameter) ctor: CallOrConstruct(n?: number) => string
  
  // 类似地，将类型为 `string` 的参数传递给 `ctor` 会将其
  // 与 `CallOrConstruct` 接口中的第二个定义匹配。
  console.log(new ctor("10")); // (parameter) ctor: CallOrConstructnew (s: string) => Date
}
```

## 泛型函数

通常我们会编写输入类型与输出类型相关的函数，或者两个输入类型以某种方式相关的函数。让我们考虑一个返回数组第一个元素的函数：

```typescript
function firstElement(arr: any[]) {
  return arr[0];
}
```

这个函数完成了它的工作，但不幸的是返回类型是 `any`。如果函数返回数组元素的类型会更好。

在 TypeScript 中，当我们想描述两个值之间的对应关系时，会使用泛型。我们通过在函数签名中声明类型参数来实现：

```typescript
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}
```

通过向此函数添加类型参数 `Type` 并在两个地方使用它，我们在函数的输入（数组）和输出（返回值）之间创建了链接。现在当我们调用它时，会出现更具体的类型：

```typescript
// s 是 'string' 类型
const s = firstElement(["a", "b", "c"]);
// n 是 'number' 类型
const n = firstElement([1, 2, 3]);
// u 是 undefined 类型
const u = firstElement([]);
```

### 推断

注意：在这个示例中，我们不必指定 `Type`。类型是由 TypeScript 自动推断选择的。

我们也可以使用多个类型参数。例如，`map` 的独立版本如下所示：

```typescript
function map<Input, Output>(arr: Input[], func: (arg: Input) => Output): Output[] {
  return arr.map(func);
}

// 参数 'n' 是 'string' 类型
// 'parsed' 是 'number[]' 类型
const parsed = map(["1", "2", "3"], (n) => parseInt(n));
```

注意：在这个例子中，TypeScript 可以推断 `Input` 类型参数的类型（从给定的字符串数组），以及基于函数表达式返回值的 `Output` 类型参数（`number`）。

### 约束

我们编写了一些可以处理任何类型值的泛型函数。有时我们想关联两个值，但只能对值的某个子集进行操作。在这种情况下，我们可以使用约束来限制类型参数可以接受的类型种类。

让我们编写一个返回两个值中较长者的函数。为此，我们需要一个数字类型的 `length` 属性。我们通过编写 `extends` 子句来约束类型参数为该类型：

```typescript
function longest<Type extends { length: number }>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}

// longerArray 是 'number[]' 类型
const longerArray = longest([1, 2], [1, 2, 3]);
// longerString 是 'alice' | 'bob' 类型
const longerString = longest("alice", "bob");
// 错误！数字没有 'length' 属性
const notOK = longest(10, 100);
// Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.
```

在这个例子中有几个有趣的点需要注意。我们允许 TypeScript 推断 `longest` 的返回类型。返回类型推断也适用于泛型函数。

因为我们约束了 `Type` 为 `{ length: number }`，所以允许访问 `a` 和 `b` 参数的 `.length` 属性。没有类型约束，我们将无法访问这些属性，因为值可能是没有 `length` 属性的其他类型。

`longerArray` 和 `longerString` 的类型是基于参数推断的。记住，泛型都是关于用相同类型关联两个或多个值的！

最后，正如我们所希望的那样，调用 `longest(10, 100)` 被拒绝，因为 `number` 类型没有 `.length` 属性。

### 使用约束值

这是使用泛型约束时的一个常见错误：

```typescript
function minimumLength<Type extends { length: number }>(obj: Type, minimum: number): Type {
  if (obj.length >= minimum) {
    return obj;
  } else {
    return { length: minimum };
    // Type '{ length: number; }' is not assignable to type 'Type'.
    // '{ length: number; }' is assignable to the constraint of type 'Type', but 'Type' could be instantiated with a different subtype of constraint '{ length: number; }'.
  }
}
```

看起来这个函数是 OK 的 - `Type` 被约束为 `{ length: number }`，函数要么返回 `Type`，要么返回匹配该约束的值。问题是函数承诺返回与传入对象相同类型的对象，而不仅仅是匹配约束的某个对象。如果这段代码是合法的，你可以编写肯定无法工作的代码：

```typescript
// 'arr' 获得值 { length: 6 }
const arr = minimumLength([1, 2, 3], 6);
// 在这里崩溃，因为数组有 'slice' 方法，但返回的对象没有！
console.log(arr.slice(0));
```

### 指定类型参数

TypeScript 通常可以推断泛型调用中的预期类型参数，但并非总是如此。例如，假设你编写了一个组合两个数组的函数：

```typescript
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}
```

通常，使用不匹配的数组调用此函数会出错：

```typescript
const arr = combine([1, 2, 3], ["hello"]);
// Type 'string' is not assignable to type 'number'.
```

但是，如果你打算这样做，可以手动指定 `Type`：

```typescript
const arr = combine<string | number>([1, 2, 3], ["hello"]);
```

## 编写良好泛型函数的指南

编写泛型函数很有趣，很容易沉迷于类型参数。拥有太多类型参数或在不需要的地方使用约束会使推断不太成功，让函数的调用者感到沮丧。

### 下推类型参数

这是两种编写看起来相似的函数的方法：

```typescript
function firstElement1<Type>(arr: Type[]) {
  return arr[0];
}

function firstElement2<Type extends any[]>(arr: Type) {
  return arr[0];
}

// a: number (好)
const a = firstElement1([1, 2, 3]);
// b: any (差)
const b = firstElement2([1, 2, 3]);
```

乍一看这些可能看起来相同，但 `firstElement1` 是编写此函数的更好方式。它的推断返回类型是 `Type`，但 `firstElement2` 的推断返回类型是 `any`，因为 TypeScript 必须使用约束类型解析 `arr[0]` 表达式，而不是在调用期间"等待"解析元素。

**规则：** 如果可能，使用类型参数本身而不是约束它

### 使用更少的类型参数

这是另一对类似的函数：

```typescript
function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
  return arr.filter(func);
}

function filter2<Type, Func extends (arg: Type) => boolean>(arr: Type[], func: Func): Type[] {
  return arr.filter(func);
}
```

我们创建了一个类型参数 `Func`，它不关联两个值。这总是一个危险信号，因为它意味着想要指定类型参数的调用者必须无缘无故地手动指定一个额外的类型参数。`Func` 除了使函数更难阅读和推理外，什么也没做！

**规则：** 始终使用尽可能少的类型参数

### 类型参数应该出现两次

有时我们忘记函数可能不需要是泛型的：

```typescript
function greet<Str extends string>(s: Str) {
  console.log("Hello, " + s);
}
```

我们可以很容易地编写一个更简单的版本：

```typescript
function greet(s: string) {
  console.log("Hello, " + s);
}
```

记住，类型参数用于关联多个值的类型。如果类型参数在函数签名中只使用一次，它就没有关联任何东西。这包括推断的返回类型；例如，如果 `Str` 是 `greet` 推断返回类型的一部分，它将关联参数和返回类型，因此尽管在编写的代码中只出现一次，但会被使用两次。

**规则：** 如果类型参数只出现在一个位置，强烈重新考虑你是否真的需要它

## 可选参数

JavaScript 中的函数通常接受可变数量的参数。例如，`number` 的 `toFixed` 方法接受一个可选的数字计数：

```typescript
function f(n: number) {
  console.log(n.toFixed()); // 0 个参数
  console.log(n.toFixed(3)); // 1 个参数
}
```

我们可以在 TypeScript 中通过用 `?` 标记参数为可选来模拟这一点：

```typescript
function f(x?: number) {
  // ...
}

f(); // OK
```

尽管参数指定为 `number` 类型，但 `x` 参数实际上将具有类型 `number | undefined`，因为 JavaScript 中未指定的参数获得值 `undefined`。

你也可以提供参数默认值：

```typescript
function f(x = 10) {
  // ...
}
```

现在在 `f` 的主体中，`x` 将具有类型 `number`，因为任何 `undefined` 参数将被替换为 `10`。注意当参数是可选的时，调用者总是可以传递 `undefined`，因为这只是模拟一个"缺失"的参数：

```typescript
// 全部 OK
f();
f(10);
f(undefined);
```

### 回调中的可选参数

一旦你了解了可选参数和函数类型表达式，在编写调用回调的函数时很容易犯以下错误：

```typescript
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}
```

当人们将 `index?` 写为可选参数时，他们通常的意图是希望这两种调用都是合法的：

```typescript
myForEach([1, 2, 3], (a) => console.log(a));
myForEach([1, 2, 3], (a, i) => console.log(a, i));
```

这实际上意味着 `callback` 可能用一个参数调用。换句话说，函数定义说实现可能看起来像这样：

```typescript
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    // 我今天不想提供索引
    callback(arr[i]);
  }
}
```

反过来，TypeScript 将强制执行这个含义，并发出并非真正可能的错误：

```typescript
myForEach([1, 2, 3], (a, i) => {
  console.log(i.toFixed());
  // 'i' is possibly 'undefined'.
});
```

在 JavaScript 中，如果你用比参数更多的参数调用函数，额外的参数将被忽略。TypeScript 的行为方式相同。具有较少参数（相同类型）的函数总是可以替代具有较多参数的函数。

**规则：** 当为回调编写函数类型时，除非你打算在不传递该参数的情况下调用函数，否则不要编写可选参数

## 函数重载

一些 JavaScript 函数可以用各种参数数量和类型调用。例如，你可以编写一个生成 `Date` 的函数，它接受时间戳（一个参数）或月/日/年规范（三个参数）。

在 TypeScript 中，我们可以通过编写重载签名来指定可以以不同方式调用的函数。为此，编写一些函数签名（通常两个或更多），后跟函数体：

```typescript
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined && y !== undefined) {
    return new Date(y, mOrTimestamp, d);
  } else {
    return new Date(mOrTimestamp);
  }
}

const d1 = makeDate(12345678);
const d2 = makeDate(5, 5, 5);
const d3 = makeDate(1, 3);
// No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.
```

在这个例子中，我们编写了两个重载：一个接受一个参数，另一个接受三个参数。前两个签名称为重载签名。

然后，我们编写了一个具有兼容签名的函数实现。函数有一个实现签名，但这个签名不能直接调用。尽管我们编写了一个在必需参数后有两个可选参数的函数，但它不能用两个参数调用！

### 重载签名和实现签名

这是一个常见的混淆源。人们经常编写这样的代码，并不理解为什么有错误：

```typescript
function fn(x: string): void;
function fn() {
  // ...
}

// 期望能够用零个参数调用
fn();
// Expected 1 arguments, but got 0.
```

同样，用于编写函数体的签名不能从外部"看到"。

实现的签名从外部不可见。编写重载函数时，你应该总是在函数的实现上方有两个或更多签名。

实现签名也必须与重载签名兼容。例如，这些函数有错误，因为实现签名没有以正确的方式匹配重载：

```typescript
function fn(x: boolean): void;
// 参数类型不对
function fn(x: string): void;
// This overload signature is not compatible with its implementation signature.
function fn(x: boolean) {}
```

```typescript
function fn(x: string): string;
// 返回类型不对
function fn(x: number): boolean;
// This overload signature is not compatible with its implementation signature.
function fn(x: string | number) {
  return "oops";
}
```

### 编写良好的重载

像泛型一样，在使用函数重载时应该遵循一些准则。遵循这些原则将使你的函数更易于调用、理解和实现。

让我们考虑一个返回字符串或数组长度的函数：

```typescript
function len(s: string): number;
function len(arr: any[]): number;
function len(x: any) {
  return x.length;
}
```

这个函数很好；我们可以用字符串或数组调用它。但是，我们不能用可能是字符串或数组的值调用它，因为 TypeScript 只能将函数调用解析为单个重载：

```typescript
len(""); // OK
len([0]); // OK
len(Math.random() > 0.5 ? "hello" : [0]);
// No overload matches this call.
// Overload 1 of 2, '(s: string): number', gave the following error.
// Argument of type 'number[] | "hello"' is not assignable to parameter of type 'string'.
// Type 'number[]' is not assignable to type 'string'.
// Overload 2 of 2, '(arr: any[]): number', gave the following error.
// Argument of type 'number[] | "hello"' is not assignable to parameter of type 'any[]'.
// Type 'string' is not assignable to type 'any[]'.
```

因为两个重载具有相同的参数数量和相同的返回类型，我们可以改为编写函数的非重载版本：

```typescript
function len(x: any[] | string) {
  return x.length;
}
```

这好多了！调用者可以用任何一种值调用它，而且作为额外的奖励，我们不必找出正确的实现签名。

**规则：** 如果可能，总是更喜欢具有联合类型的参数而不是重载

## 在函数中声明 this

TypeScript 将通过代码流分析推断函数中的 `this` 应该是什么，例如在以下情况中：

```typescript
const user = {
  id: 123,
  admin: false,
  becomeAdmin: function() {
    this.admin = true;
  },
};
```

TypeScript 理解函数 `user.becomeAdmin` 有一个对应的 `this`，即外部对象 `user`。`this`，嗯，对于很多情况来说已经足够了，但有很多情况你需要更多地控制 `this` 代表什么对象。

JavaScript 规范规定你不能有一个名为 `this` 的参数，因此 TypeScript 使用该语法空间让你声明函数体中 `this` 的类型。

```typescript
interface DB {
  filterUsers(filter: (this: User) => boolean): User[];
}

const db = getDB();
const admins = db.filterUsers(function(this: User) {
  return this.admin;
});
```

这种模式在回调风格的 API 中很常见，其中另一个对象通常控制何时调用你的函数。

注意：你需要使用 `function` 而不是箭头函数来获得此行为：

```typescript
interface DB {
  filterUsers(filter: (this: User) => boolean): User[];
}

const db = getDB();
const admins = db.filterUsers(() => this.admin);
// The containing arrow function captures the global value of 'this'.
// Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.
```

## 其他需要了解的类型

在处理函数类型时，你会想要认识一些额外的类型。像所有类型一样，你可以在任何地方使用它们，但这些在函数的上下文中尤其相关。

### void

`void` 表示不返回值的函数的返回值。它是任何时候函数没有任何返回语句，或者没有从这些返回语句返回任何显式值时的推断类型：

```typescript
// 推断的返回类型是 void
function noop() {
  return;
}
```

在 JavaScript 中，不返回任何值的函数将隐式返回值 `undefined`。但是，`void` 和 `undefined` 在 TypeScript 中不是同一个东西。在本章末尾有更多细节。

`void` 与 `undefined` 不同。

### object

特殊类型 `object` 指的是任何不是基本类型（`string`、`number`、`bigint`、`boolean`、`symbol`、`null` 或 `undefined`）的值。这与空对象类型 `{}` 不同，也与全局类型 `Object` 不同。你很可能永远不会使用 `Object`。

`object` 不是 `Object`。始终使用 `object`！

注意：在 JavaScript 中，函数值是对象：它们具有属性，在其原型链中有 `Object.prototype`，是 `instanceof Object`，你可以在它们上调用 `Object.keys`，等等。因此，函数类型在 TypeScript 中被视为 `object`。

### unknown

`unknown` 类型表示任何值。这类似于 `any` 类型，但更安全，因为对 `unknown` 值执行任何操作都是不合法的：

```typescript
function f1(a: any) {
  a.b(); // OK
}

function f2(a: unknown) {
  a.b();
  // 'a' is of type 'unknown'.
}
```

这在描述函数类型时很有用，因为你可以描述接受任何值的函数，而函数体中没有任何值。

相反，你可以描述返回 `unknown` 类型值的函数：

```typescript
function safeParse(s: string): unknown {
  return JSON.parse(s);
}

// 需要小心处理 'obj'！
const obj = safeParse(someRandomString);
```

### never

有些函数从不返回值：

```typescript
function fail(msg: string): never {
  throw new Error(msg);
}
```

`never` 类型表示从未被观察到的值。在返回类型中，这意味着函数抛出异常或终止程序的执行。

当 TypeScript 确定联合中没有任何内容时，`never` 也会出现：

```typescript
function fn(x: string | number) {
  if (typeof x === "string") {
    // 做点什么
  } else if (typeof x === "number") {
    // 做点别的
  } else {
    x; // 有类型 'never'!
  }
}
```

### Function

全局类型 `Function` 描述了像 `bind`、`call`、`apply` 这样的属性，以及 JavaScript 中所有函数值上存在的其他属性。它还有一个特殊的属性，即 `Function` 类型的值总是可以调用；这些调用返回 `any`：

```typescript
function doSomething(f: Function) {
  return f(1, 2, 3);
}
```

这是一个无类型函数调用，通常最好避免，因为不安全的 `any` 返回类型。

如果你需要接受任意函数但不打算调用它，类型 `() => void` 通常更安全。

## 剩余参数和参数

### 背景阅读：剩余参数

除了使用可选参数或重载来创建可以接受各种固定参数数量的函数外，我们还可以使用剩余参数定义接受无限数量参数的函数。

剩余参数出现在所有其他参数之后，并使用 `...` 语法：

```typescript
function multiply(n: number, ...m: number[]) {
  return m.map((x) => n * x);
}

// 'a' 获得值 [10, 20, 30, 40]
const a = multiply(10, 1, 2, 3, 4);
```

在 TypeScript 中，这些参数的类型注解隐式为 `any[]` 而不是 `any`，并且任何给定的类型注解必须为 `Array<T>` 或 `T[]` 的形式，或者元组类型（我们稍后会学习）。

### 剩余参数

相反，我们可以使用展开语法从可迭代对象（例如数组）提供可变数量的参数。例如，数组的 `push` 方法接受任意数量的参数：

```typescript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
arr1.push(...arr2);
```

注意：通常，TypeScript 不假定数组是不可变的。这可能导致一些令人惊讶的行为：

```typescript
// 推断的类型是 number[] -- "一个具有零个或多个数字的数组"，
// 不是 specifically 两个数字
const args = [8, 5];
const angle = Math.atan2(...args);
// A spread argument must either have a tuple type or be passed to a rest parameter.
```

这种情况下最好的修复方法取决于你的代码，但通常 `const` 上下文是最直接的解决方案：

```typescript
// 推断为 2 长度元组
const args = [8, 5] as const;
// OK
const angle = Math.atan2(...args);
```

## 参数解构

### 背景阅读：参数解构

你可以使用参数解构方便地将作为参数提供的对象解包到函数体中的一个或多个局部变量中。在 JavaScript 中，它看起来像这样：

```javascript
function sum({ a, b, c }) {
  console.log(a + b + c);
}

sum({ a: 10, b: 3, c: 9 });
```

对象的类型注解在解构语法之后：

```typescript
function sum({ a, b, c }: { a: number; b: number; c: number }) {
  console.log(a + b + c);
}
```

这可能看起来有点冗长，但你也可以在这里使用命名类型：

```typescript
// 与前面的例子相同
type ABC = { a: number; b: number; c: number };
function sum({ a, b, c }: ABC) {
  console.log(a + b + c);
}
```

## 函数的可分配性

### 返回类型 void

函数的 `void` 返回类型会产生一些不寻常但预期的行为。

具有 `void` 返回类型的上下文类型不会强制函数不返回某些东西。另一种说法是，具有 `void` 返回类型的上下文函数类型（`type voidFunc = () => void`），当实现时，可以返回任何其他值，但它将被忽略。

因此，以下 `() => void` 类型的实现是有效的：

```typescript
type voidFunc = () => void;

const f1: voidFunc = () => {
  return true;
};

const f2: voidFunc = () => true;

const f3: voidFunc = function() {
  return true;
};
```

当这些函数之一的返回值分配给另一个变量时，它将保留 `void` 类型：

```typescript
const v1 = f1(); // const v1: void
const v2 = f2(); // const v2: void
const v3 = f3(); // const v3: void
```

这种行为的存在使得以下代码有效，即使 `Array.prototype.push` 返回一个数字，而 `Array.prototype.forEach` 方法期望一个具有 `void` 返回类型的函数。

```typescript
const src = [1, 2, 3];
const dst = [0];

src.forEach((el) => dst.push(el));
```

还有一个特殊情况需要注意，当字面函数定义具有 `void` 返回类型时，该函数不得返回任何内容。

```typescript
function f2(): void {
  // @ts-expect-error
  return true;
}

const f3 = function(): void {
  // @ts-expect-error
  return true;
};
```

有关 `void` 的更多信息，请参阅这些其他文档条目：
- FAQ - "为什么返回非 void 的函数可分配给返回 void 的函数？"